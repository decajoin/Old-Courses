

# 数据结构实验

## PS

### 快排的板子

```c++
const int MAXN = 1e5 + 10;
int a[MAXN];
// 快速排序 
void quicksort(int l, int r)	// 对频率排序 
{
	int mid = a[(l + r)/2];
	int i = l, j = r;
	do{
		while(a[i] < mid) i++;
		while(a[j] > mid) j--;
		if(i <= j)
		{
			swap(a[i], a[j]);
			i++;
			j--;
		}
	}while(i <= j);
	if(l < j) quicksort(l, j);
	if(i < r) quicksort(i, r);
}
```

## 第一次实验

### 第一题

![image-20230301195247290](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230301195247290.png)

```c++
#include<bits/stdc++.h>
#define sc scanf
#define pr printf
#define fs(i,a,b) for(register int i=a;i<=b;i++)
#define fsu(i,a,b) for(register int i=a;i<b;i++)
#define fd(i,a,b) for(register int i=a;i>=b;i--)
#define fdu(i,a,b) for(register int i=a;i>b;i--)
#define INF 0x3fffffff
using namespace std;

typedef struct Student_{
	int num;
	char sex;
	char name[10];
	char place[50];
}Student;

int main()
{
	Student baga;
	sc("%s",&baga.name);
	printf("%s",baga.name);
 	return 0;
}
```

### 第二题

![image-20230301195318752](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230301195318752.png)

```c++
#include<bits/stdc++.h>
#define sc scanf
#define pr printf
#define fs(i,a,b) for(register int i=a;i<=b;i++)
#define fsu(i,a,b) for(register int i=a;i<b;i++)
#define fd(i,a,b) for(register int i=a;i>=b;i--)
#define fdu(i,a,b) for(register int i=a;i>b;i--)
#define INF 0x3fffffff
using namespace std;
typedef struct Student_{
	int num;
	int socre;
}Student;

typedef struct Node_{
	Student stu;
	struct Node_* next;
}Node;

void inputStudent(Node* head)
{
	Node* move = head;
	while(move->next != NULL) move = move->next;
	
	Node* fresh = (Node*)malloc(sizeof(Node));
	fresh->next = NULL;
	
	printf("请输入学生学号:");
	scanf("%d",&fresh->stu.num);
	printf("\n请输入学生成绩:");
	scanf("%d",&fresh->stu.socre);
	
	move->next = fresh;
}

void printStudent(Node* head)
{
	Node* move = head->next;
	int flag = 0;
	while(move != NULL)
	{
		printf("学号为%d的学生成绩是%d\n",move->stu.num,move->stu.socre);
		move = move->next;
		flag = 1;
	}
	if(!flag) printf("无学生信息\n");
}

int main()
{
	Node* head = (Node*)malloc(sizeof(Node));
	head->next = NULL;

	while(1)
	{
		int cns;
		sc("%d",&cns);
		switch (cns)
		{
			case 1 : inputStudent(head); break;
			case 2 : printStudent(head); break;
		}
	}
 	return 0;
}
```

### 第三题 & 第四题

![image-20230301195523426](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230301195523426.png)

```c++
#include<bits/stdc++.h>
#define sc scanf
#define pr printf
#define fs(i,a,b) for(register int i=a;i<=b;i++)
#define fsu(i,a,b) for(register int i=a;i<b;i++)
#define fd(i,a,b) for(register int i=a;i>=b;i--)
#define fdu(i,a,b) for(register int i=a;i>b;i--)
#define INF 0x3fffffff
using namespace std;
void swap1(int* a,int* b)
{
	int temp = *a;
	*a = *b;
	*b = temp;
}

void swap2(int &a,int &b)
{
	int temp = a;
	a = b;
	b = temp;
}

int main()
{
	int a,b;
	int *sa,*sb;
	sa = &a;
	sb = &b;
	scanf("%d%d",sa,sb);
//	swap1(sa,sb);
	swap2(a,b);
	printf("%d %d",a,b);
 	return 0;
}
```

### 第五题

![image-20230301195635740](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230301195635740.png)

```c++
#include<bits/stdc++.h>
#define sc scanf
#define pr printf
#define fs(i,a,b) for(register int i=a;i<=b;i++)
#define fsu(i,a,b) for(register int i=a;i<b;i++)
#define fd(i,a,b) for(register int i=a;i>=b;i--)
#define fdu(i,a,b) for(register int i=a;i>b;i--)
#define INF 0x3fffffff
using namespace std;
int a[1000];
int find_a(int n,int a[])
{
	int Max = -INF;
	int num;
	for(int i = 0;i < n;i++)
	{
		if(*(a + i) > Max)
		{
			Max = *(a + i);
			num = i;
		}
	}
	return num;
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 0;i < n;i++) scanf("%d",a + i);
	cout<<find_a(n,a);
 	return 0;
}
```

### 第六题

![image-20230301195713786](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230301195713786.png)

```c++
#include<bits/stdc++.h>
#define sc scanf
#define pr printf
#define fs(i,a,b) for(register int i=a;i<=b;i++)
#define fsu(i,a,b) for(register int i=a;i<b;i++)
#define fd(i,a,b) for(register int i=a;i>=b;i--)
#define fdu(i,a,b) for(register int i=a;i>b;i--)
#define INF 0x3fffffff
using namespace std;
const int MAXN = 10;
int score[MAXN];
int main()
{
	int sum = 0,cnt = 0;
	for(int i = 0;i < 10;i++) 
	{
		scanf("%d",score + i);
		sum += *(score + i);
	}
	double mean = sum/10.0;
	
	for(int i = 0;i < 10;i++)
	{
		if(*(score + i) > mean) cnt++;
	}
	
	printf("%lf\n",mean);
	printf("%d",cnt);
 	return 0;
}
```

### 第七题

![image-20230301195725044](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230301195725044.png)

```c++
#include<bits/stdc++.h>
#define sc scanf
#define pr printf
#define fs(i,a,b) for(register int i=a;i<=b;i++)
#define fsu(i,a,b) for(register int i=a;i<b;i++)
#define fd(i,a,b) for(register int i=a;i>=b;i--)
#define fdu(i,a,b) for(register int i=a;i>b;i--)
#define INF 0x3fffffff
using namespace std;

typedef struct Student_{
	int num;
	char name[10];
	int score[3];
}Student;

void inputStudent(Student stu[])
{
	for(int i = 0;i < 5;i++)
	{
		printf("请分别输入学生的学号，姓名，三门课分数");
		scanf("%d%s%d%d%d",&stu[i].num,&stu[i].name,&stu[i].score[0],&stu[i].score[1],&stu[i].score[2]);
	}
}

void meanStudent(Student stu[])
{
	int sum[3];
	memset(sum,0,sizeof(sum));
	for(int i = 0;i < 3;i++)
	{
		for(int j = 0;j < 5;j++)
		{
			sum[i] += stu[j].score[i];
		}
	}
	
	for(int i = 0;i < 3;i++)
	{
		printf("%.2lf\n",sum[i]/5.0);
	}
}

void printStudent(Student stu[])
{
	int sum[5],Max = -INF,flag = -1;
	memset(sum,0,sizeof(sum));
	for(int i = 0;i < 5;i++)
	{
		for(int j = 0;j < 3;j++)
		{
			sum[i] += stu[i].score[j];
		}
		if(sum[i] > Max)
		{
			Max = sum[i];
			flag = i;
		}
	}
	printf("%d %s %d %d %d",stu[flag].num,stu[flag].name,stu[flag].score[0],stu[flag].score[1],stu[flag].score[2]);
}

int main()
{
	Student stu[5];
	
	inputStudent(stu);
	meanStudent(stu);
	printStudent(stu);
	
 	return 0;
}
```

## 顺序表

### 第一章习题

![image-20230308163720409](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230308163720409.png)

![image-20230308163752733](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230308163752733.png)

![image-20230506091300042](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230506091300042.png)

![image-20230506091430785](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230506091430785.png)

![image-20230506091716616](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230506091716616.png)

![image-20230506091741760](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230506091741760.png)

### 顺序表

![image-20230308075402137](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230308075402137.png)

![image-20230308075423194](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230308075423194.png)

![image-20230308075435506](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230308075435506.png)

![image-20230308075517793](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230308075517793.png)

+ 如果空间满了后还要继续插入就选择下面的方法

![QQ图片20230308075746](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/QQ%E5%9B%BE%E7%89%8720230308075746.jpg)

![image-20230308075537072](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230308075537072.png)

![image-20230308075859694](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230308075859694.png)

![image-20230308075907723](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230308075907723.png)



## 第二次实验(顺序表)

### 第一题

![image-20230301195952470](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230301195952470.png)

![image-20230301200001157](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230301200001157.png)

```c++
#include <iostream>     
#include<stdlib.h>
#include<string.h>
using namespace std;
#define INT_LIST_SIZE 6
#define LISTINCREMENT 3

typedef struct{
    int* elem;
    int length;
    int listsize;
}SqList;

void InitList(SqList &L)
{
    L.elem = (int*)malloc(sizeof(int)*INT_LIST_SIZE);
    memset(L.elem,0,sizeof(int)*INT_LIST_SIZE);
    if(!L.elem) exit(0);
    L.length = 0;
    L.listsize = INT_LIST_SIZE;
}

void ListInsert(SqList &L,int i,int e) // 在i个位置插入元素e
{
    if(i < 1 || i > L.listsize + 1) return;
    if(L.length >= L.listsize)
    {
    	int *newbase;
        newbase = (int*)realloc(L.elem,sizeof(int)*(L.listsize + LISTINCREMENT));
        if(!newbase) exit(0);
        L.elem = newbase;
        L.listsize += LISTINCREMENT;
    }
    int* q;
    int* p;
    q = &(L.elem[i - 1]);
    
    for(p = &(L.elem[L.length - 1]);p > q;p--)
    {
        *(p + 1) = *p ;// 插入的元素向后移
    }
    *q = e;
    L.length++;
}

void ListDelet(SqList &L,int i,int &e)
{
    if(i < 1 || i > L.listsize) return ;
    int* p = &(L.elem[i - 1]);
    int* q = &(L.elem[L.length - 1]);
    e = L.elem[i - 1];
    for(p++;p <= q;p++)
    {
        *(p - 1) = *p; // 被删除元素以后的元素向左移
    }
    
    L.length--;
}

void PrintList(SqList L)
{
    for(int i = 0;i < L.length;i++) cout<<L.elem[i]<<" ";
    cout<<endl;
}

int LocateElem(SqList L,int e)
{
	int i = 0;
	int* p;
	p = &(L.elem[0]);
    while(*(p + i)!= e && i <= L.length)
    {
		i++;
	}
	if(i < L.length) return i + 1;
	else return 0;
}
int main(){
	int e,n,x;
    SqList L1;
	InitList(L1);
	
	cin >> n;
	for(int i = 1;i <= n;i++)
	{
		cin >> x;
		ListInsert(L1,i,x);
	}
	
	cin >> x;
	ListDelet(L1,x,e);
	
	cin >> x;
	LocateElem(L1,x);
	
	PrintList(L1);
	
	cout << e << endl;
	
	if(LocateElem(L1,x))	cout << LocateElem(L1,x) << endl;
	else cout<< "Not find" << endl;
	
    return 0;
}
```

### 第二题

![image-20230301202336893](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230301202336893.png)

```c++
#include <iostream>     
#include<stdlib.h>
#include<string.h>
using namespace std;
#define INT_LIST_SIZE 6
#define LISTINCREMENT 3

typedef struct{
    int* elem;
    int length;
    int listsize;
}SqList;

void InitList(SqList &L)
{
    L.elem = (int*)malloc(sizeof(int)*INT_LIST_SIZE);
    memset(L.elem,0,sizeof(int)*INT_LIST_SIZE);
    if(!L.elem) exit(0);
    L.length = 0;
    L.listsize = INT_LIST_SIZE;
}

void PrintList(SqList L)
{
    for(int i = 0;i < L.length;i++) cout<<L.elem[i]<<" ";
    cout<<endl;
}

void ListInsert_sort(SqList &L,int e)
{
	if(L.length >= L.listsize)
	{
	   	int *newbase;
	    newbase = (int*)realloc(L.elem,sizeof(int)*(L.listsize + LISTINCREMENT));
	    if(!newbase) exit(0);
	    L.elem = newbase;
		L.listsize += LISTINCREMENT;
	}
	
	int* p;
	int i = 0;
	p = &(L.elem[0]);
	while(*(p + i) <= e && i < L.length) i++;
	i++; // 上面循环得到的i是数组的下标，而之前我们后移操作的i是位置故加一 
	
	int* q;
	q = &(L.elem[i - 1]);
	    
	for(p = &(L.elem[L.length - 1]);p >= q;p--)
	{
	    *(p + 1) = *p ;// 插入的元素向后移 
	}
	*q = e;
	L.length++;
}
int main(){
	int n,x;
    SqList L1;
	InitList(L1);
	
	cin >> n;
	for(int i = 1;i <= n;i++)
	{
		cin >> x;
		ListInsert_sort(L1,x);
	}
	
	cin >> x;
	ListInsert_sort(L1,x);
	 
	PrintList(L1);
	
    return 0;
}
```

### 第三题

![image-20230307203044274](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230307203044274.png)

```c++
#include <iostream>     
#include<stdlib.h>
#include<string.h>
using namespace std;
#define INT_LIST_SIZE 6
#define LISTINCREMENT 3

typedef struct{
    int* elem;
    int length;
    int listsize;
}SqList;

void InitList(SqList &L)
{
    L.elem = (int*)malloc(sizeof(int)*INT_LIST_SIZE);
    memset(L.elem,0,sizeof(int)*INT_LIST_SIZE);
    if(!L.elem) exit(0);
    L.length = 0;
    L.listsize = INT_LIST_SIZE;
}

void PrintList(SqList L)
{
    for(int i = 0;i < L.length;i++) cout<<L.elem[i]<<" ";
    cout<<endl;
}

void ListInsert_sort(SqList &L,int e)
{
	if(L.length >= L.listsize)
	{
	   	int *newbase;
	    newbase = (int*)realloc(L.elem,sizeof(int)*(L.listsize + LISTINCREMENT));
	    if(!newbase) exit(0);
	    L.elem = newbase;
		L.listsize += LISTINCREMENT;
	}
	
	int* p;
	int i = 0;
	p = &(L.elem[0]);
	while(*(p + i) <= e && i < L.length) i++;
	i++; // 上面循环得到的i是数组的下标，而之前我们后移操作的i是位置故加一 
	
	int* q;
	q = &(L.elem[i - 1]);
	    
	for(p = &(L.elem[L.length - 1]);p >= q;p--)
	{
	    *(p + 1) = *p ;// 插入的元素向后移 
	}
	*q = e;
	L.length++;
}

void ListDelet(SqList &L,int i)
{
    if(i < 1 || i > L.listsize) return ;
    int* p = &(L.elem[i - 1]);
    int* q = &(L.elem[L.length - 1]);
    
    for(p++;p <= q;p++)
    {
        *(p - 1) = *p; // 被删除元素以后的元素向左移
    }
    
    L.length--;
}

void List_set(SqList &L)
{
	for(int i = 0;i < L.length - 1;i++)
	{
		if(L.elem[i] == L.elem[i + 1])
		{
			for(int j = i;j < L.length - 1;j++)
			{
				L.elem[j] = L.elem[j + 1];
			}
			L.length--;
			i--;
		}
	}
		
}
int main(){
	int n,x;
    SqList L1;
	InitList(L1);
	
	cin >> n;
	for(int i = 1;i <= n;i++)
	{
		cin >> x;
		ListInsert_sort(L1,x);
	}
	
	List_set(L1);
	
	PrintList(L1);
	
    return 0;
}
```

### 第四题

![image-20230307203127448](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230307203127448.png)

```c++
#include<iostream>
#include<stdlib.h>
#include<string.h>
using namespace std;
#define INT_LIST_SIZE 6
#define LISTINCREMENT 3

typedef struct{
    int* elem;
    int length;
    int listsize;
}SqList;

void InitList(SqList &L)
{
    L.elem = (int*)malloc(sizeof(int)*INT_LIST_SIZE);
    memset(L.elem,0,sizeof(int)*INT_LIST_SIZE);
    if(!L.elem) exit(0);
    L.length = 0;
    L.listsize = INT_LIST_SIZE;
}

void PrintList(SqList L)
{
    for(int i = 0;i < L.length;i++) cout<<L.elem[i]<<" ";
    cout<<endl;
}

void ListInsert_sort(SqList &L,int e)
{
	if(L.length >= L.listsize)
	{
	   	int *newbase;
	    newbase = (int*)realloc(L.elem,sizeof(int)*(L.listsize + LISTINCREMENT));
	    if(!newbase) exit(0);
	    L.elem = newbase;
		L.listsize += LISTINCREMENT;
	}
	
	int* p;
	int i = 0;
	p = &(L.elem[0]);
	while(*(p + i) <= e && i < L.length) i++;
	i++; // 上面循环得到的i是数组的下标，而之前我们后移操作的i是位置故加一 
	
	int* q;
	q = &(L.elem[i - 1]);
	    
	for(p = &(L.elem[L.length - 1]);p >= q;p--)
	{
	    *(p + 1) = *p ;// 插入的元素向后移 
	}
	*q = e;
	L.length++;
}

SqList ListScanf(SqList L1,SqList L2)
{
	SqList L3,L4;
	InitList(L3);
	InitList(L4);
	// 类似归并排序的方法，首先将两个有序表组合 
	int i = 0,j = 0;
	while(i < L1.length && j < L2.length)
	{
		if(L1.elem[i] < L2.elem[j])
		{
			int x = L1.elem[i];
			ListInsert_sort(L3,x);
			i++;
		}
		else
		{
			int x = L2.elem[j];
			ListInsert_sort(L3,x);
			j++;			
		}
	}
	while(i < L1.length)
	{
		int x = L1.elem[i];
		ListInsert_sort(L3,x);
		i++;		
	}
	while(j < L2.length)
	{
		int x = L2.elem[j];
		ListInsert_sort(L3,x);
		j++;		
	}
	
	// 最后遍历上面组合形成的有序表重复的加入L4
for(int i = 0;i < L3.length - 1;i++)
	{
		if(L3.elem[i] == L3.elem[i + 1])
		{
			int x = L3.elem[i];
			ListInsert_sort(L4,x);
		}
	}	
	return L4;
}
int main()
{
	int n,x;
    SqList L1,L2;
	InitList(L1);
	InitList(L2);

	
	cin >> n;
	for(int i = 1;i <= n;i++)
	{
		cin >> x;
		ListInsert_sort(L1,x);
	}
	
	cin >> n;
	for(int i = 1;i <= n;i++)
	{
		cin >> x;
		ListInsert_sort(L2,x);
	}	
//	PrintList(L1);
//	PrintList(L2);
	PrintList(ListScanf(L1,L2));
	return 0;
}
```

### 第五题

![image-20230307203151041](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230307203151041.png)

```c++
#include<iostream>
#include<stdlib.h>
#include<string.h>
using namespace std;
#define INT_LIST_SIZE 6
#define LISTINCREMENT 3

typedef struct{
    int* elem;
    int length;
    int listsize;
}SqList;

void InitList(SqList &L)
{
    L.elem = (int*)malloc(sizeof(int)*INT_LIST_SIZE);
    memset(L.elem,0,sizeof(int)*INT_LIST_SIZE);
    if(!L.elem) exit(0);
    L.length = 0;
    L.listsize = INT_LIST_SIZE;
}

void PrintList(SqList L)
{
    for(int i = 0;i < L.length;i++) cout<<L.elem[i]<<" ";
    cout<<endl;
}

void ListInsert_sort(SqList &L,int e)
{
	if(L.length >= L.listsize)
	{
	   	int *newbase;
	    newbase = (int*)realloc(L.elem,sizeof(int)*(L.listsize + LISTINCREMENT));
	    if(!newbase) exit(0);
	    L.elem = newbase;
		L.listsize += LISTINCREMENT;
	}
	
	int* p;
	int i = 0;
	p = &(L.elem[0]);
	while(*(p + i) <= e && i < L.length) i++;
	i++; // 上面循环得到的i是数组的下标，而之前我们后移操作的i是位置故加一 
	
	int* q;
	q = &(L.elem[i - 1]);
	    
	for(p = &(L.elem[L.length - 1]);p >= q;p--)
	{
	    *(p + 1) = *p ;// 插入的元素向后移 
	}
	*q = e;
	L.length++;
}

void ListCompare(SqList L1,SqList L2)
{
	int i = 0,j = 0;
	while(i < L1.length && i < L2.length)
	{
		if(L1.elem[i] < L2.elem[i])
		{
			cout<<"A<B"<<endl;
			exit(0);
		}
		else if(L1.elem[i] > L2.elem[i])
		{
			cout<<"A>B"<<endl;
			exit(0);
		}
		i++;
	}
	if(L1.length == L2.length) cout<<"A=B"<<endl;
	else
	{
		if(i < L1.length) cout<<"A>B"<<endl;
		else cout<<"A<B"<<endl;
	}	
}

int main()
{
	int n,x;
    SqList L1,L2;
	InitList(L1);
	InitList(L2);

	
	cin >> n;
	for(int i = 1;i <= n;i++)
	{
		cin >> x;
		ListInsert_sort(L1,x);
	}

	cin >> n;
	for(int i = 1;i <= n;i++)
	{
		cin >> x;
		ListInsert_sort(L2,x);
	}	
	
	ListCompare(L1,L2);
	return 0;
}
```

## 链表

![image-20230308141028957](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230308141028957.png)

![image-20230308080219645](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230308080219645.png)

![image-20230308080244812](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230308080244812.png)

![image-20230308080302184](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230308080302184.png)

![image-20230308080317683](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230308080317683.png)

![image-20230308080333626](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230308080333626.png)

![image-20230308080405412](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230308080405412.png)

![image-20230308080451766](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230308080451766.png)

![image-20230308080500238](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230308080500238.png)

![image-20230308085230393](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230308085230393.png)

![QQ图片20230308085154](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/QQ%E5%9B%BE%E7%89%8720230308085154.png)

### 循环链表

![image-20230308083532599](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230308083532599.png)

![image-20230308083709118](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230308083709118.png)

### 双向链表

![image-20230308083959277](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230308083959277.png)

![image-20230308084102251](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230308084102251.png)

![image-20230308084027599](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230308084027599.png)

### 链表和顺序表比较   

![image-20230308084350393](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230308084350393.png)

![image-20230308084615780](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230308084615780.png)

![image-20230308145518186](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230308145518186.png)

![image-20230308145539806](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230308145539806.png)

### 链表应用

![image-20230308143209206](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230308143209206.png)

### 第二章习题

![image-20230412172145700](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230412172145700.png)

![image-20230412172215454](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230412172215454.png)

![image-20230412172240157](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230412172240157.png)

+ ==先将p结点后面的连在s后再断开p->next==

![image-20230412182329605](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230412182329605.png)

+ ==双向链表插入==

![image-20230412182816789](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230412182816789.png)

![image-20230308161706790](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230308161706790.png)

```c++
void MergeList(LinkList& La, LinkList& Lb, LinkList& Lc, ) 
{// 合并链表 La 和 Lb，合并后的新表使用头指针 Lc 指向
	 pa=La->next; pb=Lb->next; 
	//pa 和 pb 分别是链表 La 和 Lb 的工作指针 , 初始化为相应链表的第一个结点
	 Lc=pc=La; // 用 La 的头结点作为 Lc 的头结点
	 Lc->next=NULL; 
	 while(pa||pb ) 
	{// 只要存在一个非空表，用 q 指向待摘取的元素
	 	if(!pa) 
	 		{q=pb; pb=pb->next;} 
	//La 表为空，用 q 指向 pb ， pb 指针后移
	 	else if(!pb) 
	 		{q=pa; pa=pa->next;} 
	//Lb 表为空，用 q 指向 pa ， pa 指针后移
	 	else if(pa->data<=pb->data) 
	 		{q=pa; pa=pa->next;} 
	// 取较小者（包括相等） La 中的元素，用 q 指向 pa， pa 指针后移
		else 
			{q=pb; pb=pb->next;} 
	// 取较小者 Lb 中的元素，用 q 指向 pb， pb 指针后移
	 q->next = Lc->next; Lc->next = q; 
	// 将 q 指向的结点插在 Lc 表的表头结点之后!!!!!!!!!!!!
	} 
	delete Lb; // 释放 Lb 的头结点
} 
```

Ps. delete函数的用法

![image-20230308165447157](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230308165447157.png)

![image-20230308170043796](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230308170043796.png)

![image-20230308170555833](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230308170555833.png)

```c++
void Mix(LinkList& La, LinkList& Lb, LinkList& Lc) 
{pa=La->next;pb=Lb->next; 
	pa 和 pb 分别是链表 La 和 Lb 的工作指针 , 初始化为相应链表的第一个结点
	Lc=pc=La; // 用 La 的头结点作为 Lc 的头结点
	while(pa&&pb) 
	{ 
		if(pa->data==pb- >data) ∥交集并入结果表中。
	 		{ pc->next=pa;pc=pa;pa=pa->next; 
	u=pb;pb=pb->next; delete u;} 
		else if(pa->data<pb->data) 
			{u=pa;pa=pa->next; delete u;} 
		else 
			{u=pb; pb=pb->next; delete u;} 
	} 
	while(pa){u=pa; pa=pa->next; delete u;} ∥ 释放结点空间
	while(pb) {u=pb; pb=pb->next; delete u ;} ∥释放结点空间
	pc- >next=null; ∥置链表尾标记。
	delete Lb; // 释放 Lb 的头结点
 }

```

#### 第二章线性表算法设计题

![image-20230325145851911](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230325145851911.png)

```c++
第一题
void compare(SqList L1,SqList L2)
{
	if(L1.length == L2.length && L1.length == 0) 
	{
		cout<< "A=B";
		return;
	}
	
	int i = 1;
	int e;
	while(L1.elem[i - 1] == L2.elem[i - 1])
	{
		ListDelet(L1,i,e);	// 删除第一个元素 
		ListDelet(L2,i,e);	// while可以删除所有的相同前缀 
	}
	if(L1.elem[0] == L2.elem[0] || (L1.length == L2.length && L1.length == 0) )cout<< "A=B";
	else if(L1.elem[0] > L2.elem[0] || (L2.length == 0 && L1.length > 0)) cout << "A>B";
	else cout << "A<B";
	
}

第二题
void inverse(SqList &L)
{
	for(int i = 0;i < L.length/2;i++)	
	{
		int temp = L.elem[i];
		L.elem[i] = L.elem[L.length - i -1];
		L.elem[L.length - i - 1] = temp;
	}
}

第三题
int LENGTH(LinkList L)
{
	LinkList r = L->next;
	int cnt = 0;
	while(r != NULL)
	{
		cnt++;
		r = r->next;
	}
	return cnt;
}

第四题
LinkList merge(LinkList &L1,LinkList &L2)
{
	LinkList hc;
	int len1 = ListLength(L1);
	int len2 = ListLength(L2);
	if(len1 == 0 && len2 > 0) hc = L2;
	else if(len2 == 0 && len1 > 0) hc = L1;
	else if(len1 >= len2)
	{
		hc = L2;
		LinkList r;
		r = L2;
		while(r->next != NULL)
		{
			r = r->next;
		}
		r->next = L1->next;
	}
	else if(len1 < len2)
	{
		hc = L1;
		LinkList r;
		r = L1;
		while(r->next != NULL)
		{
			r = r->next;
		}
		r->next = L2->next;		
	}
	return hc;
}
算法复杂度分析：L1长度为m，L2长度为n，若m<n是O(m),若m>n是O(n)

第五题
void deletrange(LinkList &L,int mink,int maxk)	// 链表是单增的 
{
	LinkList l,r;
	l = L;
	r = L;
	while(l->next->data < mink)
	{
		l = l->next;
	}
	while(r->next->data < maxk)
	{
		r = r->next;
	}
	LinkList x;
	x = l->next;	
	l->next = r->next->next;
	free(x);
}
算法复杂度分析： 复杂度取决与maxk值的大小，最差算法复杂度是O(n),n是链表的长度

第六题

void inverse(LinkList L)
{
    LinkList p;
    p = L->next;
    L->next = NULL;
    while(p != NULL)
	{
        LNode *tmp;
        tmp = p->next;
        p->next = L->next;
        L->next = p;
        p = tmp;
    }
}

第七题
LinkList locationlist(LinkList L,LinkList p)	// 寻找p结点的前驱
{
	LinkList q;
	q = p;
	while(q->next != p)
	{
		q = q->next;
	}
	return q;
}
void deletlist(LinkList &L,LinkList s)
{
	LinkList p1, p2;
	p1 = locationlist(L,s);		// 调用两次找到s的前驱结点点的前驱结点
	p2 = locationlist(L,p1);
	p2->next = s;				// 删除操作
	free(p1);					// 释放删除的结点
}
```

```c++
#include <iostream>     
#include<stdlib.h>
#include<string.h>
using namespace std;
#define INT_LIST_SIZE 6
#define LISTINCREMENT 3

typedef struct{
    int* elem;
    int length;
    int listsize;
}SqList;

void InitList(SqList &L)
{
    L.elem = (int*)malloc(sizeof(int)*INT_LIST_SIZE);
    memset(L.elem,0,sizeof(int)*INT_LIST_SIZE);
    if(!L.elem) exit(0);
    L.length = 0;
    L.listsize = INT_LIST_SIZE;
}

void ListInsert(SqList &L,int i,int e) // 在i个位置插入元素e
{
    if(i < 1 || i > L.listsize + 1) return;
    if(L.length >= L.listsize)
    {
    	int *newbase;
        newbase = (int*)realloc(L.elem,sizeof(int)*(L.listsize + LISTINCREMENT));
        if(!newbase) exit(0);
        L.elem = newbase;
        L.listsize += LISTINCREMENT;
    }
    int* q;
    int* p;
    q = &(L.elem[i - 1]);
    
    for(p = &(L.elem[L.length - 1]);p > q;p--)
    {
        *(p + 1) = *p ;// 插入的元素向后移
    }
    *q = e;
    L.length++;
}

void ListDelet(SqList &L,int i,int &e)
{
    if(i < 1 || i > L.listsize) return ;
    int* p = &(L.elem[i - 1]);
    int* q = &(L.elem[L.length - 1]);
    e = L.elem[i - 1];
    for(p++;p <= q;p++)
    {
        *(p - 1) = *p; // 被删除元素以后的元素向左移
    }
    
    L.length--;
}

void PrintList(SqList L)
{
    for(int i = 0;i < L.length;i++) cout<<L.elem[i]<<" ";
    cout<<endl;
}

int LocateElem(SqList L,int e)
{
	int i = 0;
	int* p;
	p = &(L.elem[0]);
    while(*(p + i)!= e && i <= L.length)
    {
		i++;
	}
	if(i < L.length) return i + 1;
	else return 0;
}
// 第一题 
void compare(SqList L1,SqList L2)
{
	if(L1.length == L2.length && L1.length == 0) 
	{
		cout<< "A=B";
		return;
	}
	
	int i = 1;
	int e;
	while(L1.elem[i - 1] == L2.elem[i - 1])
	{
		ListDelet(L1,i,e);	// 删除第一个元素 
		ListDelet(L2,i,e);	// while可以删除所有的相同前缀 
	}
	if(L1.elem[0] == L2.elem[0] || (L1.length == L2.length && L1.length == 0) )cout<< "A=B";
	else if(L1.elem[0] > L2.elem[0] || (L2.length == 0 && L1.length > 0)) cout << "A>B";
	else cout << "A<B";	
}
// 第二题 
void inverse(SqList &L)
{
	for(int i = 0;i < L.length/2;i++)	
	{
		int temp = L.elem[i];
		L.elem[i] = L.elem[L.length - i -1];
		L.elem[L.length - i - 1] = temp;
	}
}
int main(){
	int n,x,m;
    SqList L1;
    SqList L2;
	InitList(L1);
	InitList(L2);
	
	cin >> n;
	for(int i = 1;i <= n;i++)
	{
		cin >> x;
		ListInsert(L1,i,x);
	}	
	
//	cin >> m;
//	for(int i = 1;i <= m;i++)
//	{
//		cin >> x;
//		ListInsert(L2,i,x);
//	}	
		
	inverse(L1);
	PrintList(L1);
    return 0;
}
```

```c++
#include<iostream>
#include<stdlib.h>
using namespace std;

typedef struct Node{
	int data;
	struct Node *next;
}LNode,*LinkList;


void InitList(LinkList &L)
{
	L = (LinkList)malloc(sizeof(LNode));
	L->next = NULL;
}

void CreatList(LinkList &L,int n)
{
	LinkList p,r;
	r = L;
	for(int i = 0;i < n;i++)
	{
		int data;
		cin >> data;
		p = (LinkList)malloc(sizeof(LNode));
		p->data = data;
		p->next = NULL;
		r->next = p; 
		r = p;
	}
}

void PrintList(LinkList &L)
{
	LinkList r = L->next;
	
	while(r != NULL)
	{
		cout << r->data << " ";
		r = r->next;
	}
	cout << endl;
}

bool ListInsert(LinkList &L,int i,int e)
{
	if(i < 1 ) 
	{
		cout<< "Insertion Location Error" << endl;
		return false;
	}
	
	LinkList r = L,p;
	for(int j = 0;j < i - 1;j++)
	{
		r = r->next;
	}
	
	if(r == NULL)
	{
		cout<< "Insertion Location Error" << endl;
		return false;		
	} 

	p = (LinkList)malloc(sizeof(LNode));
	p->data = e;
	p->next = r->next;
	r->next = p;
	return true;
}


bool ListDelete(LinkList &L,int n,int &e)
{
	if(n < 1)
	{
		cout<< "Deletion Location Error" << endl;
		return false;	
	}
	
	LinkList r = L,p;
	for(int j = 0;j < n - 1;j++)
	{
		r = r->next;
	}
	if(r->next == NULL) // 注意我们删除第n个元素时是找到n前面那个元素 
	{
		cout<< "Deletion Location Error" << endl;
		return false;
	}
	
    p = r->next;
	e = r->next->data;
	r->next = p->next;
    free(p);
}

int ListLength(LinkList L)
{
	LinkList r = L->next;
	int cnt = 0;
	while(r != NULL)
	{
		cnt++;
		r = r->next;
	}
	return cnt;
}

LinkList merge(LinkList &L1,LinkList &L2)
{
	LinkList hc;
	int len1 = ListLength(L1);
	int len2 = ListLength(L2);
	if(len1 == 0 && len2 > 0) hc = L2;
	else if(len2 == 0 && len1 > 0) hc = L1;
	else if(len1 >= len2)
	{
		hc = L2;
		LinkList r;
		r = L2;
		while(r->next != NULL)
		{
			r = r->next;
		}
		r->next = L1->next;
	}
	else if(len1 < len2)
	{
		hc = L1;
		LinkList r;
		r = L1;
		while(r->next != NULL)
		{
			r = r->next;
		}
		r->next = L2->next;		
	}
	return hc;
}

void deletrange(LinkList &L,int mink,int maxk)	// 链表是单增的 
{
	LinkList l,r;
	l = L;
	r = L;
	while(l->next->data < mink)
	{
		l = l->next;
	}
	while(r->next->data < maxk)
	{
		r = r->next;
	}
	LinkList x;
	x = l->next;	
	l->next = r->next->next;
	free(x);
}

void inverse(LinkList L)
{
    LinkList p;
    p = L->next;
    L->next = NULL;
    while(p != NULL)
	{
        LNode *tmp;
        tmp = p->next;
        p->next = L->next;
        L->next = p;
        p = tmp;
    }
}

void initlist(LinkList &L)
{
	L = (LinkList)malloc(sizeof(LNode));
	L->next = NULL;
}
void creatlist(LinkList &L,int n)
{
	int x;
	cin >> x;
	L->data = x;
	LinkList r;
	r = L;
	for(int i = 0;i < n - 1;i++)
	{
		cin >> x;
		LinkList p;
		p = (LinkList)malloc(sizeof(LNode));
		p->data = x;
		r->next = p;
		p->next = L;
		r = p;	
	}
}
LinkList locationlist(LinkList L,LinkList p)
{
	LinkList q;
	q = p;
	while(q->next != p)
	{
		q = q->next;
	}
	return q;
}
void deletlist(LinkList &L,LinkList s)
{
	LinkList p1, p2;
	p1 = locationlist(L,s);
	p2 = locationlist(L,p1);
	p2->next = s;
	free(p1);
}
void printlist(LinkList L,LinkList s)
{
	LinkList p = s;
	while(p->next != s)
	{
		cout << p->data << " ";
		p = p->next;
	}
	cout << p->data;
}

int main()
{
	LinkList L1;
	LinkList L2;
	
	int x;
	cin >> x;
	initlist(L1);
	creatlist(L1,x);
	LinkList s;
	s = L1->next;
	cout<< s->data <<endl;
	deletlist(L1,s);
	printlist(L1,s);
	
	
 	return 0;
}
```

## 第三次实验（链表）

### 第一题

![](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230312085101201.png)

![image-20230312085122695](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230312085122695.png)

```c++
#include<iostream>
#include<stdlib.h>
using namespace std;

typedef struct Node{
	int data;
	struct Node *next;
}LNode,*LinkList;


void InitList(LinkList &L)
{
	L = (LinkList)malloc(sizeof(LNode));
	L->next = NULL;
}

void CreatList(LinkList &L,int n)
{
	LinkList p,r;
	r = L;
	for(int i = 0;i < n;i++)
	{
		int data;
		cin >> data;
		p = (LinkList)malloc(sizeof(LNode));
		p->data = data;
		p->next = NULL;
		r->next = p; 
		r = p;
	}
}

void PrintList(LinkList &L)
{
	LinkList r = L->next;
	
	while(r != NULL)
	{
		cout << r->data << " ";
		r = r->next;
	}
	cout << endl;
}

bool ListInsert(LinkList &L,int i,int e)
{
	if(i < 1 ) 
	{
		cout<< "Insertion Location Error" << endl;
		return false;
	}
	
	LinkList r = L,p;
	for(int j = 0;j < i - 1;j++)
	{
		r = r->next;
	}
	
	if(r == NULL)
	{
		cout<< "Insertion Location Error" << endl;
		return false;		
	} 

	p = (LinkList)malloc(sizeof(LNode));
	p->data = e;
	p->next = r->next;
	r->next = p;
	return true;
}


bool ListDelete(LinkList &L,int n,int &e)
{
	if(n < 1)
	{
		cout<< "Deletion Location Error" << endl;
		return false;	
	}
	
	LinkList r = L,p;
	for(int j = 0;j < n - 1;j++)
	{
		r = r->next;
	}
	if(r->next == NULL) // 注意我们删除第n个元素时是找到n前面那个元素 
	{
		cout<< "Deletion Location Error" << endl;
		return false;
	}
	
    p = r->next;
	e = r->next->data;
	r->next = p->next;
    free(p);
}

int ListLength(LinkList L)
{
	LinkList r = L->next;
	int cnt = 0;
	while(r != NULL)
	{
		cnt++;
		r = r->next;
	}
	return cnt;
}
int main()
{
	LinkList L;
	int n1,n2,n3,x;
	int e;
	
	InitList(L);
	
	cin >> n1;
	CreatList(L,n1);

	cin >> n2 >> x;
	cin >> n3;
	
	ListInsert(L,n2,x);
	
	if(ListDelete(L,n3,e)) cout<< e << endl;// 只有删除操作成功时才输出e 
	
	cout<< ListLength(L) << endl;
	
	PrintList(L);

 	return 0;
}
```

### 第二题

![image-20230312085210193](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230312085210193.png)

```c++
#include<iostream>
#include<stdlib.h>
using namespace std;

typedef struct Node{
	int data;
	struct Node* next;
}LNode,*LinkList;

void InitList(LinkList &L)
{
	L = (LinkList)malloc(sizeof(Node));
	L->next = NULL;	
}

void ListInsert(LinkList &L)
{
	int x = 0;
	LinkList p,r;
	p = L; // 尾插法 
	while(cin >> x && x != -1)
	{
		r = (LinkList)malloc(sizeof(Node));
		r->data = x;
		r->next = NULL;
		p->next = r;
		p = r; // p始终是链表的尾 
	}
	return;
}

void PrintList(LinkList &L)
{
	LinkList r = L->next;
	
	while(r != NULL)
	{
		cout << r->data << " ";
		r = r->next;
	}
	cout << endl;
}

void ListSort(LinkList &L1,LinkList &L2,LinkList &L3)
{
	LinkList p1 = L1->next,p2 = L2->next;
	LinkList p3;
	L3 = p3 = L1;
	while(p1 && p2)
	{
		if(p2->data > p1->data)
		{
			p3->next = p1;
			p1 = p1->next;
			p3 = p3->next;
			p3->next = NULL;
		}
		else if(p2->data < p1->data)
		{
			p3->next = p2;
			p2 = p2->next;
			p3 = p3->next;
			p3->next = NULL;
		}
		else
		{
			p3->next = p1;
			p1 = p1->next;
			p2 = p2->next;
			p3 = p3->next;
			p3->next = NULL;
		}
	}
	p3->next = p1 ? p1 : p2;
}

int main()
{
	LinkList L1;
	LinkList L2;
	LinkList L3;
	
	InitList(L1);
	ListInsert(L1);
	
	InitList(L2);
	ListInsert(L2);
	
	
	ListSort(L1,L2,L3);
	
	
	PrintList(L3);
	return 0;
}
```

+ ps.第二题开辟空间

```c++
#include<iostream>
#include<stdlib.h>
using namespace std;

typedef struct Node{
	int num;
	int x;
	struct Node *next;
}LNode,*LinkList;

void InitList(LinkList &L)
{
	L = (LinkList)malloc(sizeof(LNode));
	L->next = NULL;
}

void ListInsert(LinkList &L,int n)
{
	LinkList r = L,p;
	for(int i = 0;i < n;i++)
	{
		int num,x;
		cin >> num >> x;
		p = (LinkList)malloc(sizeof(LNode));
		p->num = num;
		p->x = x;
		r->next = p;
		p->next = NULL;
		r = p;
	}
}

void PrintList(LinkList &L)
{
	LinkList r = L->next;
	
	while(r != NULL)
	{
		cout << r->num << " " << r->x<<" ";
		r = r->next;
	}
	cout << endl;
}


void sum(LinkList &L1,LinkList &L2,LinkList &L3)
{
	LinkList p1 = L1->next,p2 = L2->next;
	LinkList p3 = L3;
	while(p1 && p2)
	{
		if(p1->x > p2->x)
		{
			p3->next = p1;
			p1 = p1->next;
			p3 = p3->next;
			p3->next = NULL;
		}
		else if(p1->x < p2->x)
		{
			p3->next = p2;
			p2 = p2->next;
			p3 = p3->next;	
			p3->next = NULL;		
		}
		else
		{
			p3->next = p1;
			p3->next->num = p1->num + p2->num;
			p1 = p1->next;
			p2 = p2->next;
			p3 = p3->next;
			p3->next = NULL;
		}
	}
	p3->next = p1 ? p1 : p2;
}

int main()
{
	int n1,n2;
	cin >> n1;
	LinkList L1,L2,L3;
	InitList(L1);
	InitList(L2);
	InitList(L3);
	ListInsert(L1,n1);
	cin >> n2;
	ListInsert(L2,n2);
	sum(L1,L2,L3);
	PrintList(L3);
	return 0;
}
```

### 第三题

![image-20230312085248867](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230312085248867.png)

```c++
#include<iostream>
#include<stdlib.h>
using namespace std;

typedef struct Node{
	int data;
	struct Node* next;
}LNode,*LinkList;

void InitList(LinkList &L)
{
	L = (LinkList)malloc(sizeof(Node));
	L->next = NULL;	
}

void ListInsert(LinkList &L)
{
	int x = 0;
	LinkList p,r;
	p = L; // 尾插法 
	while(cin >> x && x != -1)
	{
		r = (LinkList)malloc(sizeof(Node));
		r->data = x;
		r->next = NULL;
		p->next = r;
		p = r; // p始终是链表的尾 
	}
	return;
}

void PrintList(LinkList &L)
{
	LinkList r = L->next;
	
	while(r != NULL)
	{
		cout << r->data << " ";
		r = r->next;
	}
	cout << endl;
}

void ListSort(LinkList &L1,LinkList &L2,LinkList &L3)
{
	LinkList p1 = L1->next,p2 = L2->next;
	LinkList p3 = L3;
	LinkList r;
	while(p1 && p2)
	{
		if(p2->data > p1->data)
		{
			p1 = p1->next;
		}
		else if(p2->data < p1->data)
		{
			p2 = p2->next;
		}
		else
		{
			r = (LinkList)malloc(sizeof(LNode));
			r->data = p1->data;			
			p3->next = r;
			p1 = p1->next;
			p2 = p2->next;
			p3 = p3->next;
			p3->next = NULL;
		}
	}
}

int main()
{
	LinkList L1;
	LinkList L2;
	LinkList L3;
	
	InitList(L1);
	ListInsert(L1);
	
	InitList(L2);
	ListInsert(L2);
	
	InitList(L3);
	
	ListSort(L1,L2,L3);
	
	
	PrintList(L3);
	return 0;
}
```

### 第四题

![image-20230312085900096](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230312085900096.png)

```c++
#include<iostream>
#include<stdlib.h>
using namespace std;

typedef struct Node{
	int code;
	int key;
	struct Node* next;
}LNode,*LinkList;

void InitList(LinkList &L)
{
	L = (LinkList)malloc(sizeof(LNode));
	L->next = NULL;
}

void ListInsert(LinkList &L,int n)
{
	LinkList r = L,p;
	for(int i = 1;i <= n;i++)
	{
		int m;
		cin >> m;
		p = (LinkList)malloc(sizeof(LNode));
		p->key = m;
		p->code = i;
		p->next = NULL;
		r->next	= p;
		r = p;
	}
}

int pop(LinkList &L)
{
	if(L->next == NULL) exit(0);
	LinkList r = L->next;
	L->next = L->next->next;
	return r->code;
}

void push(LinkList &L)
{
	if(L->next == NULL) return;
	LinkList r = L->next,p = L;
	if(L->next != NULL) L->next = L->next->next;
	while(p->next != NULL)
	{
		p = p->next;
	}
	p->next = r;
	r->next = NULL;
}

void PrintList(LinkList &L)
{
	LinkList r = L->next;
	
	while(r != NULL)
	{
		cout << r->key << " ";
		r = r->next;
	}
	cout << endl;
}

void Joseph(LinkList &L,int m)
{
	while(L->next != NULL)
	{
		for(int i = 0;i < m - 1;i++)
		{
			push(L);
		}
		m = L->next->key;
		cout<< pop(L) << " ";
			
	}
}


int main()
{
	int m,n;
	cin >> m >> n;
	
	LinkList L;
	InitList(L);
	ListInsert(L,n);
	Joseph(L,m);
	PrintList(L);
	
	return 0;
}
```

### 第五题

![image-20230312085929544](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230312085929544.png)

```c++
#include<iostream>
#include<stdlib.h>
using namespace std;

typedef struct Node{
	int num;
	int x;
	struct Node *next;
}LNode,*LinkList;

void InitList(LinkList &L)
{
	L = (LinkList)malloc(sizeof(LNode));
	L->next = NULL;
}

void ListInsert(LinkList &L,int n)
{
	LinkList r = L,p;
	for(int i = 0;i < n;i++)
	{
		int num,x;
		cin >> num >> x;
		p = (LinkList)malloc(sizeof(LNode));
		p->num = num;
		p->x = x;
		r->next = p;
		p->next = NULL;
		r = p;
	}
}

void PrintList(LinkList &L)
{
	LinkList r = L->next;
	
	while(r != NULL)
	{
		cout << r->num << " " << r->x<<" ";
		r = r->next;
	}
	cout << endl;
}


void sum(LinkList &L1,LinkList &L2,LinkList &L3)
{
	LinkList p1 = L1->next,p2 = L2->next;
	LinkList p3 = L3;
	while(p1 && p2)
	{
		if(p1->x > p2->x)
		{
			p3->next = p1;
			p1 = p1->next;
			p3 = p3->next;
			p3->next = NULL;
		}
		else if(p1->x < p2->x)
		{
			p3->next = p2;
			p2 = p2->next;
			p3 = p3->next;	
			p3->next = NULL;		
		}
		else
		{
			p3->next = p1;
			p3->next->num = p1->num + p2->num;
			p1 = p1->next;
			p2 = p2->next;
			p3 = p3->next;
			p3->next = NULL;
		}
	}
	p3->next = p1 ? p1 : p2;
}

int main()
{
	int n1,n2;

	LinkList L1,L2,L3;
    
	InitList(L1);
	InitList(L2);
	InitList(L3);
    
    cin >> n1;
	ListInsert(L1,n1);
	cin >> n2;
	ListInsert(L2,n2);
    
	sum(L1,L2,L3);
    
	PrintList(L3);
	return 0;
}
```

## 栈

#### 第三章习题

![image-20230412160723048](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230412160723048.png)

![image-20230412160909291](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230412160909291.png)

![image-20230412161208948](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230412161208948.png)

![image-20230412161307200](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230412161307200.png)

![image-20230412161339601](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230412161339601.png)

![image-20230412161423952](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230412161423952.png)

> (6）假设以带头结点的循环链表表示队列，并且只设一个指针指向队尾元素站点 ( 注意不
> 设头指针 ) ，试编写相应的置空队、判队空、入队和出队等算法。
> [ 题目分析 ]
> 置空队就是建立一个头节点，并把头尾指针都指向头节点，头节点是不存放数据的；判
> 队空就是当头指针等于尾指针时，队空；入队时，将新的节点插入到链队列的尾部，同时将
> 尾指针指向这个节点；出队时，删除的是队头节点，要注意队列的长度大于 1 还是等于 1 的
> 情况，这个时候要注意尾指针的修改，如果等于 1，则要删除尾指针指向的节点。
> [算法描述 ]
>
> ```c++
> //先定义链队结构 : 
> typedef struct queuenode 
> {
> 	Datatype data; 
> 	struct queuenode *next; 
> }QueueNode; // 以上是结点类型的定义
> 
> typedef struct 
> {
> 	queuenode *rear; 
> }LinkQueue; // 只设一个指向队尾元素的指针
> ```

(1) 置空队

```c++
void InitQueue( LinkQueue *Q) 
{ // 置空队：就是使头结点成为队尾元素
	QueueNode *s; 
	Q->rear = Q->rear->next;// 将队尾指针指向头结点
	while (Q->rear!=Q->rear->next)// 当队列非空，将队中元素逐个出队
	{
		s=Q->rear->next; 
		Q->rear->next=s->next; 
	}
	delete s; 
}// 回收结点空间
```

(2) 判队空

```
int EmptyQueue( LinkQueue *Q) 
{ // 判队空。当头结点的 next 指针指向自己时为空队
	return Q->rear->next->next==Q->rear->next; 
} 	
```

==(3) 入队==

```c++
void EnQueue( LinkQueue *Q, Datatype x) 
{ // 入队。````````````````````````````也就是在尾结点处插入元素
	QueueNode *p=new QueueNode;// 申请新结点
	p->data=x; p->next=Q->rear->next;// 初始化新结点并链入
	Q-rear->next=p; 
	Q->rear=p;// 将尾指针移至新结点
} 
```

==(4) 出队==

```c++
Datatype DeQueue( LinkQueue *Q) 
{// 出队 ,把头结点之后的元素摘下
	Datatype t; 
	QueueNode *p; 
	if(EmptyQueue( Q )) 
		Error("Queue underflow"); 
	p=Q->rear->next->next; //p 指向将要摘下的结点
    // rear->next就相当于头指针！！！
	x=p->data; // 保存结点中数据
	if (p==Q->rear) 
	{// 当队列中只有一个结点时， p 结点出队后，要将队尾指针指向头结点
		Q->rear = Q->rear->next; 
		Q->rear->next=p->next; 
	} 
	else 
		Q->rear->next->next=p->next;// 摘下结点 p 
	delete p;// 释放被删结点
	return x; 
} 
```
---
**第七题就是利用一个操作符来判断Q.rear==Q.front时到底是队空还是队满，这样就可以不浪费空间**

> （ 7）假设以数组 Q[ m] 存放循环队列中的元素 , 同时设置一个标志 tag ，以 tag== 0 和 tag == 1 来区别在队头指针 ( front )和队尾指针 ( rear )相等时，队列状态为 “空 ”还是 “满 ”。试编写与此结构相应的插入 (enqueue )和删除 (dlqueue )算法。
> [算法描述 ]
>
> ```c++
> SeQueue QueueInit(SeQueue Q) 
> {// 初始化队列
> 	Q.front=Q.rear=0; Q.tag=0; 
> 	return Q; 
> } 
> ```

(2) 入队

```c++
SeQueue QueueIn(SeQueue Q,int e) 
{// 入队列
	if((Q.tag==1) && (Q.rear==Q.front)) 
		cout<<" 队列已满 "<<endl; 
	else 
	{
		Q.rear=(Q.rear+1) % m; 
		Q.data[Q.rear]=e; 
		if(Q.tag==0) Q.tag=1; // 队列已不空
	} 
	return Q; 
} 
```

(3) 出队

```c++
ElemType QueueOut(SeQueue Q) 
{// 出队列
	if(Q.tag==0) { 
		cout<<" 队列为空 "<<endl; exit(0);} 
	else 
		{Q.front=(Q.front+1) % m; 
	e=Q.data[Q.front]; 
	if(Q.front==Q.rear) Q.tag=0; // 空队列
	} 
	return(e); 
} 
```

---

> （ 10）已知 f 为单链表的表头指针 , 链表中存储的都是整型数据，试写出实现下列运算
> 的==递归算法==：
> ①求链表中的最大整数；
> ②求链表的结点个数；
> ③求所有整数的平均值。

1. ```c++
   int GetMax(LinkList p) 
   { 
   	if(!p->next) 
   		return p->data; 
   	else 
   	{ 
   		int max=GetMax(p->next); 
   		return p->data>=max ? p->data:max; 
   	} 
   } 
   ```

2. ```c++
   int GetLength(LinkList p) 
   { 
   	if(!p->next) 
   		return 1; 
   	else 
   	{ 
   		return GetLength(p->next)+1; 
   	} 
   } 
   ```

3. ```c++
   double GetAverage(LinkList p , int n) 
   { 
   	if(!p->next) 
   		return p->data; 
   	else 
   	{ 
   		double ave=GetAverage(p->next,n-1); 
   		return (ave*(n-1)+p->data)/n; 
   	} 
   }
   ```

   





## 第四次实验（栈）

### 头文件

```c++
#ifndef MYSTACK1_H
#define MYSTACK1_H
#include<iostream>
#include<stdlib.h>
using namespace std;

#define INIT_SIZE 100	// 存储空间初始分配量
#define INCREMENT 10	//存储空间分配增量

typedef struct{
	int *base;
	int *top;
	int StackSize;
}SqStack;
 
void InitStack(SqStack &S)
{
	S.base = (int*)malloc(INIT_SIZE*sizeof(int));
	if(!S.base) exit(-1);
	S.top = S.base;
	S.StackSize = INIT_SIZE;
	return;
}

bool StackEmpty(SqStack S)
{
	if(!S.base) exit(-1);
	if(S.top == S.base) return true;
	else return false;
}

void push(SqStack &S,int x)
{
	if(S.top - S.base == S.StackSize)	//栈满 
	{	
		int *newbase;	//准备新基址 
		newbase = (int*)realloc(S.base,(S.StackSize + INCREMENT)*sizeof(int));
		if(!newbase) exit(-1);
		S.base = newbase;
		S.top = S.StackSize + S.base;	// 找到现在top指针的位置  
		S.StackSize += INCREMENT;
	}
	*S.top++ = x;	// 由于赋值后top++，top始终是空的 
	return;
}

void pop(SqStack &S,int &e)
{
	if(S.top == S.base) exit(-1);
	e = *--S.top;
}

void top(SqStack S,int &e)
{
	if(S.top == S.base) return;
	e = *(S.top - 1);
}

void travel(SqStack S)	// 将栈的数据元素从栈底到栈顶依次显示
{
	while(S.top != S.base)
	{
		cout << *S.base++ << " ";
	}
	cout << endl;
}

#endif
```

```c++
#ifndef MYSTACK2_H
#define MYSTACK2_H
#include<iostream>
#include<stdlib.h>
using namespace std;

typedef struct StackNode{
	int data;
	struct StackNode *next;
}SNode,*LinkStack;

typedef struct StackNodeS{
	char data;
	struct StackNodeS *next;
}SNodeS,*LinkStackS;

void InitStack(LinkStack &S)
{
	S = NULL;	// S是栈顶 
}

bool StackEmpty(LinkStack S)
{
	if(S == NULL) return true;
	else return false;
}

void push(LinkStack &S,int x)	// 不用考虑栈满问题 
{
	LinkStack p;
	p = (LinkStack)malloc(sizeof(SNode));
	p->data = x;
	p->next = S;  
	S = p;	// 移动S使之成为栈顶 
}

void pop(LinkStack &S,int &e)
{
	if(S == NULL) return;
	LinkStack p;
	p = S;
	e = p->data;
	S = S->next;
	free(p);
}

void top(LinkStack S,int &e)
{
	if(S == NULL) return;
	e = S->data;
}

void travel(LinkStack S)	// 将栈的数据元素从栈顶到栈底依次显示 
{
	while(S != NULL)
	{
		cout << S->data << " ";
		S = S->next;
	}
}

void InitStackS(LinkStackS &S)
{
	S = NULL;
}

void pushS(LinkStackS &S,char x)
{
	LinkStackS p;
	p = (LinkStackS)malloc(sizeof(StackNodeS));
	p->data = x;
	p->next = S;
	S = p;
}

void popS(LinkStackS &S,char &e)
{
	LinkStackS p = S;
	e = p->data;
	S = S->next;
	free(p);
}

void topS(LinkStackS S,char &e)
{
	if(S == NULL) return;
	e = S->data;
}

bool StackEmptyS(LinkStackS S)
{
	if(S == NULL) return true;
	else return false;
}

void calculate(LinkStack &numStack,char e)
{
	int num1,num2,res;
	pop(numStack,num2);
	pop(numStack,num1);
	switch(e)
	{
		case '+' : 
		{
			res = num1 + num2;
			push(numStack,res);
		}
		break;
		case '-' :
		{
			res = num1 - num2;
			push(numStack,res);
		}
		break;
		case '*' :
		{
			res = num1 * num2;
			push(numStack,res);
		}
		break;
		case '/' :
		{
			res = num1 / num2;
			push(numStack,res);
		}
		break;
	}
}
#endif
```

### 第一题

![image-20230323004158137](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230323004158137.png)

```c++
#include<iostream>
#include"mystack1.h"

using namespace std;

int main()
{
	SqStack S;
	InitStack(S);
	int n;
	int e;
	cin >> n;
	for(int i = 0;i < n;i++)
	{
		int x;
		cin >> x;
		push(S,x);
	}
	
	cin >> n;
	for(int i = 0;i < n;i++) pop(S,e);
	
	if(StackEmpty(S)) cout << "Y";
	else cout << "N";
	
	if(!StackEmpty(S))
	{
		top(S,e);
		cout << endl;
		cout << e << endl;
	
		travel(S);
	}
	return 0;
}
```

### 第二题

![image-20230323004332527](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230323004332527.png)

```c++
#include<iostream>
#include"mystack2.h"
using namespace std;

int main()
{
	LinkStack S;
	InitStack(S);
	int n;
	int e;
	cin >> n;
	for(int i = 0;i < n;i++)
	{
		int x;
		cin >> x;
		push(S,x);
	}
	
	cin >> n;
	for(int i = 0;i < n;i++) pop(S,e);
	
	if(StackEmpty(S)) cout << "Y";
	else cout << "N";
	
	if(!StackEmpty(S))
	{
		top(S,e);
		cout << endl;
		cout << e << endl;
		
		travel(S);	
	}
	return 0;
}
```

### 第三题

![image-20230323004352071](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230323004352071.png)

```c++
#include<iostream>
#include"mystack2.h"

using namespace std;

void PrintStack(LinkStack S)
{
	while(S != NULL)
	{
		cout << S->data;
		S = S->next;
	}
	cout << endl;
}

int main()
{
	LinkStack S;
	InitStack(S);
	int n;
	cin >> n;
	
	while(n != 0)
	{
		push(S,n % 8);
		n /= 8;
	}
	
	PrintStack(S);
	return 0;
}
```

### 第四题

![image-20230323004412072](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230323004412072.png)

```c++
/*
(1) 先计算括号内，后计算括号外；
(2) 在无括号或同层括号内，先乘除运算，后加减运算，即乘除运算的优先级高于加减运算的优先级；
(3) 同一优先级运算，从左向右依次进行。
*/
#include<iostream>
#include<string.h>
#include"mystack2.h"

using namespace std;
const int MAXN = 1e5 + 10;
char s[MAXN];


int main()
{
	LinkStack numStack;
	LinkStackS operatorStack;
	
	InitStack(numStack);
	InitStackS(operatorStack);
	
	int n = 0;
	scanf("%s",s);
	int lenght = strlen(s);

	for(int i = 0;i < lenght;i++)
	{
		if(s[i] >= '0' && s[i] <= '9')	// 将数字处理压栈 
		{
			n = s[i] - '0';
			while(i < lenght)
			{
				if(s[i + 1] >= '0' && s[i] <= '9')
				{
					n = n*10 + (s[i + 1] - '0');
					i++;
				}
				else break;
			}
			push(numStack,n);
		}
		else if(s[i] == '+' || s[i] =='-' || s[i] == '*' || s[i] == '/' || s[i] == '(' || s[i] == ')')	// 处理算术符 
		{
			char e;
			topS(operatorStack,e);			
			switch(s[i])
			{
				case '+' :
				{
					if(e != '+' && e != '-' && e != '*' && e != '/')
					{
						pushS(operatorStack,'+');
					}
					else
					{
						while(!StackEmptyS(operatorStack) && e != '(')
						{
							popS(operatorStack,e);
							calculate(numStack,e);
							topS(operatorStack,e);
						}
						pushS(operatorStack,'+');
					}
				}
				break;
				case '-' :
				{
					if(e != '+' && e != '-' && e != '*' && e != '/')
					{
						pushS(operatorStack,'-');
					}
					else
					{
						while(!StackEmptyS(operatorStack) && e != '(')
						{
							popS(operatorStack,e);
							calculate(numStack,e);
							topS(operatorStack,e);
						}
						pushS(operatorStack,'-');						
					}
				}
				break;
				case '*' :
				{
					if(e != '*' && e != '/')
					{
						pushS(operatorStack,'*');
					}
					else
					{
						while(!StackEmptyS(operatorStack) && e != '(')
						{
							popS(operatorStack,e);
							calculate(numStack,e);
							topS(operatorStack,e);
						}
						pushS(operatorStack,'*');							
					}					
				}
				break;
				case '/' :
				{
					if(e != '*' && e != '/')
					{
						pushS(operatorStack,'/');
					}
					else
					{
						while(!StackEmptyS(operatorStack) && e != '(')
						{
							popS(operatorStack,e);
							calculate(numStack,e);
							topS(operatorStack,e);
						}
						pushS(operatorStack,'/');							
					}					
				}					
				break;
				case '(' :
				{
					pushS(operatorStack,'(');
				}
				break;
				case ')' :
				{
					while(e != '(')
					{
						popS(operatorStack,e);
						calculate(numStack,e);	
						topS(operatorStack,e);					
					}
					popS(operatorStack,e);
				}
				break;
			}
		}
	}
	
	char x;
	while(!StackEmptyS(operatorStack)) 
	{
		popS(operatorStack,x);
		calculate(numStack,x);
	}
	
	int ans;
	top(numStack,ans);
	cout << ans;
}
```

### 第五题

![image-20230323004431421](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230323004431421.png)

```c++
#include<iostream>

using namespace std;

int n = 1;
void move(char a,int n,char b)
{
	cout << n << ":" << " ";
	cout << n << " " << a << " " << b <<endl;
	n++;
}

void hanoi(int n,char x,char y,char z)
{
	if(n == 1) move(x,1,z);	// 将编号为1的圆盘从x移到z 
	else
	{
		hanoi(n - 1,x,z,y);	// 将x上编号为1到n-1的圆盘移到y，z作辅助塔  
		move(x,n,z);		// 将编号为n的圆盘从x移到z 
		hanoi(n - 1,y,x,z);	// 将y上编号为1到n-1的圆盘移到z，x作辅助塔 
	}
}

int main()
{
	int n;
	cin >> n;
	hanoi(n,'A','B','C');
	return 0;
}
```

## 第五次实验（队列）

### 头文件

```c++
#ifndef MYQUEUE1_H
#define MYQUEUE1_H
#include<iostream>
#include<cstdlib>
using namespace std;

typedef struct QNode{
    int data;
    struct QNode *next;
}QNode,*QueuePtr;

typedef struct{
    QueuePtr front;
    QueuePtr rear;
}LinkQueue;

void InitQueue(LinkQueue &Q)
{
    Q.front = Q.rear = (QueuePtr)malloc(sizeof(QNode));
    Q.front->next = NULL;
}

void DestroyQueue(LinkQueue &Q)
{
    while(Q.front)
    {
        Q.rear = Q.front->next;
        free(Q.front);
        Q.front = Q.rear;
    }
}
 
 void EnQueue(LinkQueue &Q, int e)
 {
     QueuePtr p;
     p = (QueuePtr)malloc(sizeof(QNode));
     p->data = e;
     p->next = NULL;
     Q.rear->next = p;
     Q.rear = p;
 }
 
 void DeQueue(LinkQueue &Q, int &e)
 {
     QueuePtr p;
     if(Q.front == Q.rear) return;
     p = Q.front->next;
     e = p->data;
     Q.front->next = p->next;
     if(Q.rear == p) Q.rear = Q.front;
     free(p);
 }
 
 void PrintQueue(LinkQueue Q)
 {
     QueuePtr p;
     p = Q.front->next;
     while(p != NULL)
     {
         cout << p->data << " ";
         p = p->next;
     }
 }
 
 bool isEmptyQueue(LinkQueue Q)
 {
    if(Q.front == Q.rear) return true;
    else return false;
 }

 void TopQueue(LinkQueue Q, int &e)
 {
    e = Q.front->next->data;
 }

int QueueLength(LinkQueue Q)
{
	int cnt = 0;
	QueuePtr p;
	p = Q.front->next;
	while(p != NULL)
	{
		cnt++;
		p = p->next;
	}
	return cnt;
}
#endif
```

```c++
#include <iostream>
#include"myQueue2.h"
using namespace std;

int main(){
    int e, n;
    LinkQueue Q;

    InitQueue(Q);
        cin >> n;
        for(int i = 0;i < n;i++)
        {
            int x;
            cin >> x;
            EnQueue(Q, x);
        }

        cin >> n;
        for(int i = 0;i < n;i++)    DeQueue(Q, e);

        if(!isEmptyQueue(Q))
        {
            cout << "N" << endl;
            TopQueue(Q, e);
            cout << e << endl;
            PrintQueue(Q);
            cout << endl;
        }
        else cout<< "Y";
}
```

```c++
#ifndef MYSTACK2_H
#define MYSTACK2_H
#include<iostream>
#include<stdlib.h>
using namespace std;

typedef struct StackNode{
	int data;
	struct StackNode *next;
}SNode,*LinkStack;

typedef struct StackNodeS{
	char data;
	struct StackNodeS *next;
}SNodeS,*LinkStackS;

void InitStack(LinkStack &S)
{
	S = NULL;	// S是栈顶 
}

bool StackEmpty(LinkStack S)
{
	if(S == NULL) return true;
	else return false;
}

void push(LinkStack &S,int x)	// 不用考虑栈满问题 
{
	LinkStack p;
	p = (LinkStack)malloc(sizeof(SNode));
	p->data = x;
	p->next = S;  
	S = p;	// 移动S使之成为栈顶 
}

void pop(LinkStack &S,int &e)
{
	if(S == NULL) return;
	LinkStack p;
	p = S;
	e = p->data;
	S = S->next;
	free(p);
}

void top(LinkStack S,int &e)
{
	if(S == NULL) return;
	e = S->data;
}

void travel(LinkStack S)	// 将栈的数据元素从栈顶到栈底依次显示 
{
	while(S != NULL)
	{
		cout << S->data << " ";
		S = S->next;
	}
}

int StackLength(LinkStack S)
{
	int cnt = 0;
	while(S != NULL)
	{
		cnt++;
		S = S->next;
	}
	return cnt;
}

int StackFind(LinkStack S, int num)
{
	int cnt = 0;
	int flag = 0;
	if(S->data / 10000 == num) return 0;
	while(S->data / 10000 != num && S != NULL)
	{
		cnt++;
		flag = 1;
		S = S->next;
	}
	if(flag) return cnt;
	else return -1;
}

#endif
```

### 第一题

![image-20230330082123922](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230330082123922.png)

```c++
#include <iostream>
#include"myQueue1.h"
using namespace std;

int main(){
    int e, n;
    LinkQueue Q;

    InitQueue(Q);
        cin >> n;
        for(int i = 0;i < n;i++)
        {
            int x;
            cin >> x;
            EnQueue(Q, x);
        }

        cin >> n;
        for(int i = 0;i < n;i++)    DeQueue(Q, e);

        if(!isEmptyQueue(Q))
        {
            cout << "N" << endl;
            TopQueue(Q, e);
            cout << e << endl;
            PrintQueue(Q);
            cout << endl;
        }
        else cout<< "Y";
}
```

### 第二题

![image-20230330082214205](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230330082214205.png)

```c++
#ifndef MYQUEUE2_H
#define MYQUEUE2_H
#include<iostream>
#include<cstdlib>
using namespace std;

typedef struct QNode{
    int data;
    struct QNode *next;	
}QNode,*QueuePtr;

typedef struct{
    QueuePtr front;
    QueuePtr rear;
}LinkQueue;

void InitQueue(LinkQueue &Q)
{
	Q.front = Q.rear = (QueuePtr)malloc(sizeof(QNode));
	Q.front->next = NULL;
}

void EnQueue(LinkQueue &Q, int e)
{
	QueuePtr p;
	p = (QueuePtr)malloc(sizeof(QNode));
	p->data = e;
	p->next = NULL;
	Q.rear->next = p;
	Q.rear = p;
	Q.rear->next = Q.front;
}

void DeQueue(LinkQueue &Q, int &e)
{
	if(Q.front == Q.rear) return;
	QueuePtr p;
	p = Q.front->next;
	e = p->data;
	Q.front->next = p->next;
	if(Q.rear == p) Q.rear = Q.front;
	free(p);
}

void TopQueue(LinkQueue Q, int &e)
{
	e = Q.front->next->data;
}

bool isEmptyQueue(LinkQueue Q)
{
	if(Q.front == Q.rear) return true;
	else return false;
}

void PrintQueue(LinkQueue Q)
{
	QueuePtr p;
	p = Q.front->next;
	while(p != Q.front)
	{
		cout << p->data << " ";
		p = p->next;
	}
}

#endif
```

### 第三题

![image-20230330082304276](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230330082304276.png)

![image-20230330082317003](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230330082317003.png)

![image-20230330082326925](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230330082326925.png)



```c++
#include<iostream>
#include"myQueue1.h"
#include"mystack2.h"
using namespace std;

void Arrival(LinkStack &P, LinkQueue &Q, int n, int num, int time)
{
	int Len_P = StackLength(P);
	int Len_Q = QueueLength(Q);
	// 压位 - 由于头文件中data是一个数据，在这里我们把num和time压位再存入栈
	int comx = num * 10000 + time;
	if(Len_P < n)
	{
		push(P, comx);
		Len_P++;
		cout << "parking location:" << Len_P << endl;
	}
	else
	{
		EnQueue(Q, comx);
		Len_Q++;
		cout << "sidewalk location:" << Len_Q << endl;
	}
}

void Leave(LinkStack &P, LinkQueue &Q, LinkStack &T, int n, int num,int time)
{
	int x = StackFind(P, num);
	int e;
	if(n != -1)
	{
		for(int i = 0;i < x;i++)
		{
			pop(P, e);
			push(T ,e);
		}
		pop(P, e);
		// 对压位数据处理，提取到进入停车场的时间 
		int time1 = e - 10000 * num;
		int ans = time - time1;
		cout << "time: " << ans << " parking fees: " << ans << endl;
		for(int i = 0;i < x;i++)
		{
			pop(T, e);
			push(P, e);
		}
		int Len_Q = QueueLength(Q);
		// 只有等待队列中有车辆时才出队 
		if (Len_Q > 0)
		{
			DeQueue(Q, e);
			// 更新从队列进入栈的车的进入停车场的时间 
			int num1 = e / 10000;
			e = num1 * 10000 + time;
			push(P, e); 
		}
	}
	else cout<< "车牌号码输入错误" << endl;
	
}
int main()
{
	LinkStack P;
	LinkStack T;
	LinkQueue Q;
	InitQueue(Q);
	InitStack(P);
	InitStack(T);
	char ch;
	int n, num, time;
	
	cin >> n;
	getchar();
	
	while(1)
	{
		printf("\n  A. The Car Arrive  D. The Car Leave   E. Exit System\n");
		scanf("%c%d%d",&ch, &num, &time);
		getchar();	// 消除回车对ch值的影响 
		switch(ch) 
		{
			case 'A': Arrival(P, Q, n, num, time);  break; /*车辆到达*/
			case 'D': Leave(P, Q, T, n, num, time);    break; /*车辆离开*/
			case 'E': return 0;          /*退出主程序*/ 
			default: break;
		}
	}
	
	return 0;
}
```

## 第六次实验（树）

### 头文件

```c++
#ifndef MYBTREE_H
#define MYBTREE_H
#include<iostream>
#include"myQueue.h"
using namespace std;
//typedef struct BiTNode{
//	char data;
//	struct BiTNode *lchild, *rchild;
//}BiTNode, *BiTree;

// 创建树 
void CreatBiTree(BiTree &T)
{
	char a;
	cin >> a;
	if(a == '*') T = NULL;
	else
	{
		T = (BiTree)malloc(sizeof(BiTNode));
		T->data = a;
		CreatBiTree(T->lchild);
		CreatBiTree(T->rchild);
	}
}

// 先序遍历 
void PreOrder(BiTree T)
{
	if(T)
	{
		cout << T->data;
		PreOrder(T->lchild);
		PreOrder(T->rchild);
	}
}

// 中序遍历 
void InOrder(BiTree T)
{
	if(T)
	{
		InOrder(T->lchild);
		cout << T->data;
		InOrder(T->rchild);
	}
}

// 后序遍历 
void PostOrder(BiTree T)
{
	if(T)
	{
		PostOrder(T->lchild);
		PostOrder(T->rchild);
		cout << T->data;
	}
}

// 求二叉树的叶子结点数 
// 开全局变量的方法 
int cnt = 0;
int LeefCount1(BiTree T)
{
	if(T)
	{
		if(T->lchild == NULL && T->rchild == NULL)
		{
			cnt++;
		}
		LeefCount1(T->lchild);
		LeefCount1(T->rchild);
	}
	return cnt;
}

// 求二叉树的叶子结点数 
// 不开全局变量 
int LeefCount2(BiTree T)
{
	if(T == NULL) return 0;
	if(T->rchild == NULL && T->lchild == NULL) return 1;
	return LeefCount2(T->lchild) + LeefCount2(T->rchild);	
}

// 求树的深度 
int dcount = 0;
int dL = 0, dR = 0;
int DeepCount(BiTree T)
{
	if(T == NULL) dcount = 0;
	else
	{
		dL = DeepCount(T->lchild);	//计算左子树的深度 
		dR = DeepCount(T->rchild);	//计算右子树的深度 
		dcount = 1 + (dL > dR ? dL : dR);	//二叉树的深度为较大者加1(加上刚开始的根结点)
	}
	return dcount;	
}

// 交换树的左子树和右子树 
void InverseTree(BiTree &T)
{
	BiTree temp;
	if(T == NULL) return;
	else
	{
		temp = T->lchild;
		T->lchild = T->rchild;
		T->rchild = temp;
		InverseTree(T->lchild);
		InverseTree(T->rchild);		
	}
}

// 层次遍历 
void LayerOrder(BiTree T)
{
	LinkQueue Q;	// 创建队列 
	BiTree a;		// 创建一个树节点a 
	InitQueue(Q);	// 初始化队列 
	EnQueue(Q, T);	// 将根节点入队 
	while(!isEmptyQueue(Q))	// 循环直到队空 
	{
		DeQueue(Q, a);		// 出队元素(指针)，赋给a 
		cout << a->data;	// 访问a所指结点
		if(a->lchild != NULL) EnQueue(Q, a->lchild);	// 入队a的左孩子 
		if(a->rchild != NULL) EnQueue(Q, a->rchild);	// 入队a的右孩子 
	}
}
#endif 


```

### 第一题

![image-20230426141924183](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230426141924183.png)

```c++
#include<iostream>
#include"myBTree.h"
using namespace std;
int main()
{
	BiTree T;
	CreatBiTree(T);
	
	PreOrder(T);
	cout << " ";
	InOrder(T);
	cout << " ";
	PostOrder(T);
	cout << endl;
	
	cout << LeefCount2(T);
	cout << " ";
	cout << DeepCount(T);
	cout << endl;
	
	InverseTree(T);
	
	PreOrder(T);
	cout << " ";
	InOrder(T);
	cout << " ";
	PostOrder(T);	
	
	return 0;
}
```

### 第二题

![image-20230426142056105](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230426142056105.png)

```c++
#include<iostream>
#include"myBTree.h"
using namespace std;
int main()
{
	BiTree T;

	CreatBiTree(T);
	
	LayerOrder(T);
	return 0;
}
```

### 第三题

![image-20230426142440911](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230426142440911.png)

+ Demo1（不成功）:clown_face:

```c++
#include<iostream>
#include<cstdlib>
#include<cstring>
#include"myBTree.h"
using namespace std;

// 霍夫曼编码 

/*
1）将信源符号的概率按减小的顺序排队。

2）把两个最小的概率相加，并继续这一步骤，始终将较高的概率分支放在右边，直到最后变成概率１。

3）画出由概率１处到每个信源符号的路径，顺序记下沿路径的０和１，所得就是该符号的霍夫曼码字。   

4）将每对组合的左边一个指定为0，右边一个指定为1（或相反）。
*/

typedef struct{
	int val;
	int parent, lchild, rchild;
	int num;	// 结点的序号 
	char code[100];
}HTNode, *HuffmanTree;
//typedef char* *HuffmanCode;

// 对结构体按权值大小排序 
void HuffmanSort(HuffmanTree &HT, int l, int r)
{
	int i = l;
	int j = r;
	int mid = HT[(l + r) / 2].val;
	do{
		while(HT[i].val < mid) i++;
		while(HT[j].val > mid) j--;
		if(i <= j)
		{
			char temp[100];
			swap(HT[i].val, HT[j].val);
			swap(HT[i].parent, HT[j].parent);
			swap(HT[i].lchild, HT[j].lchild);
			swap(HT[i].rchild, HT[j].rchild);
			swap(HT[i].num, HT[j].num);
			strcpy(temp, HT[i].code);
			strcpy(HT[i].code, HT[j].code);
			strcpy(HT[j].code, temp);
			HT[HT[i].rchild].parent = HT[j].num;
			HT[HT[i].lchild].parent = HT[j].num;
			i++;
			j--; 
		}
	}while(i <= j);
	if(l < j) HuffmanSort(HT, l, j);
	if(i < r) HuffmanSort(HT, i, r);	
}



// w是权值对应数组， n是要构造的个数， HT是构造的哈夫曼树 
void HuffmanCoding(HuffmanTree &HT, int *w, int n)
{
	HuffmanTree p;
	int i;
	// 特判 
	if(n <= 1) return;
	// 创造哈夫曼树的结点 
	int m = 2 * n - 1;	// 由哈夫曼构造树性质得n个结点完成构造后一共2n-1个结点 
	HT = (HuffmanTree)malloc(sizeof(HTNode) * (m + 1));			// 0单元未用  
	// 初始化创造的结点 
	for(p = HT + 1,i = 1;i <= n;++i, ++p, ++w) *p={*w, 0, 0, 0, i};	//初始化前n个单元(给每个元素赋上权值，父母结点都赋0)
	for(;i <= m;++i, ++p)   *p ={0, 0, 0, 0, i};  //对叶子之后的存储单元清零 
	// 创建哈夫曼树 
	int j = 1;
	for(int i = n + 1;i <= m;i++)
	{
		// 对结点排序 
		HuffmanSort(HT, j, i - 1);
		HT[i].val = HT[j].val + HT[j + 1].val;
		// 给这个新结点的左右孩子赋值 
		HT[i].lchild = HT[j].num;
		HT[i].rchild = HT[j + 1].num;
		// 给新结点赋上序号 
		HT[i].num = i;		
		// 给两个结点的parent赋值 
		HT[j].parent = HT[i].num;
		HT[j + 1].parent = HT[i].num;
		// 此后排序应该跳过这两个结点 
		j += 2;	
	}
	 
}	

void GetHuffmanCode(HuffmanTree &HT, int n)
{
	for(int i = 1;i <= n;i++)
	{ 
		int t = i;
		while(HT[t].parent != 2 * n - 1)
		{
			if(HT[HT[t].parent].rchild == HT[t].num) strcat(HT[i].code, "1");
			else if(HT[HT[t].parent].lchild == HT[t].num) strcat(HT[i].code, "0");
			t = HT[t].parent;
		}
		// 最后也就是parent结点是最上面那个结点的时候 
		if(HT[2 * n - 1].rchild == HT[t].num) strcat(HT[i].code, "1");
		else if(HT[2 * n - 1].lchild == HT[t].num) strcat(HT[i].code, "0");
		
	}	 
}

int main()
{
	const int MAXN = 1000;
	HuffmanTree HT;
	int w[MAXN];
	int n;
	cin >> n;
	for(int i = 0; i < n;i++) cin >> w[i];

	HuffmanCoding(HT, w, n);
	
	GetHuffmanCode(HT, n);
	
	for(int i = 1;i <= n;i++) cout << HT[i].code << " ";
				
	return 0;
}
```

> ==教材版本==
>
> > 对于Select函数该如何实现
> >
> > 原本想的是对哈夫曼树进行排序取前面两个结点，但是排序会涉及到交换结点的值之类的（非常复杂很绕）
> >
> > 参考老师代码
> >
> > 她的实现思路是每次只找权值最小的结点，然后把这个结点的parent赋值为1避免下次再查找一遍 
> >
> > > 为什么可以把parent赋值为1？
> > >
> > > 因为找到权值最小的两个结点之后我们会再次对其操作，对其parent赋值为i，所以前面赋值1是可行的
> >
> > Select函数只需要调用两次找最小的函数就行

```c++
#include<iostream>
#include<cstdlib>
#include<cstring>
#define INF 0x3fffffff
using namespace std;
const int MAXN = 1000;
int w[MAXN];

typedef struct{
	//结点的权值 
	int weight;
	//结点的双亲、左孩子、右孩子的下标 
	int parent, lchild, rchild;
	//结点的序号
	int num;
}HTNode, *HuffmanTree;
typedef char* *HuffmanCode;

int min(HuffmanTree HT,int n)
{
	int m;
	int k = INF;
	for(int i = 1;i <= n;i++)
	{
		if(HT[i].weight < k &&HT[i].parent == 0)
		{
			k = HT[i].weight;
			m = i;
		}
	}
	// m就是权值最小的结点的序号 
	HT[m].parent = 1;	// 标记该结点避免二次查找 
	return m;
}

//在HT[1…i-1]选择parent为0且weight最小的两个结点,其序号分别为s1和s2 
void Select(HuffmanTree HT, int n, int &s1, int &s2)
{
	s1 = min(HT, n);
	s2 = min(HT, n);
}


// *w是权值数组的头指针 
void HuffmanCoding(HuffmanTree &HT, HuffmanCode &HC, int *w, int n)
{
	if(n <= 1) return;
	int m = 2 * n - 1;	//n 个叶子的Huffman树共有2n-1个结点 
	HT=(HuffmanTree)malloc((m + 1)*sizeof(HTNode));   //0单元未用，给所有的结点分配空间 
	int i;
	HuffmanTree p;
	
	// 初始化哈夫曼树  
	w++;	// w下标从1开始 
	for(p = HT + 1,i = 1; i<=n; ++i,++p,++w)	//初始化前n个单元 
	{
		p->parent = 0;
		p->lchild = 0;
		p->rchild = 0;
		p->weight = *w;
		p->num = i;
	}
	for(;i <= m;++i, ++p)	//对叶子之后的存储单元清零 
	{
		p->parent = 0;
		p->lchild = 0;
		p->rchild = 0;
		p->weight = 0;
		p->num = i;
	}
	
	//建Huffman树  
	for(i=n+1;i<=m; ++i)	  
	{
	    //在HT[1…i-1]选择parent为0且weight最小的两个结点,其序号分别为s1和s2 
		int s1, s2;
		Select(HT, i-1, s1, s2);
		HT[s1].parent=i;	HT[s2].parent=i; 
 		HT[i].lchild=s1; 	HT[i].rchild=s2;  //s1、s2分别作为i的左右孩子 
		HT[i].weight=HT[s1].weight+ HT[s2].weight;
	}	
	
	//从叶子到根逆向求每个字符的赫夫曼编码 
	HC = (HuffmanCode)malloc((n + 1) * sizeof(char*));	//  分配n个字符编码的头指针 
	char* cd;
	cd = (char*)malloc(n * sizeof(char));	// 分配求编码的工作空间 
	cd[n - 1] = '\0';	//编码结束符（从cd[0]~cd[n-1]为合法空间）
	//逐个字符求Huffman编码 
	for(i=1;i<=n;++i)
	{
		int start = n-1;  //编码结束符位置 
		int c, f;
		for(c = i,f = HT[i].parent;f != 0;   c = f, f = HT[f].parent)
		{
			//从叶子到根逆向求编码 
			if(HT[f].lchild == c) cd[--start] = '0';
			else cd[--start] = '1';
			
		}
		//为第i个字符编码分配空间 
		HC[i] = (char*)malloc((n - start) * sizeof(char));
		strcpy(HC[i], &cd[start]);	//从cd复制编码串到HC		
	}
	free(cd);	//释放工作空间 
	
}

int main()
{
	int n, x;
	cin >> n;
	for(int i = 1;i <= n;i++)
	{
		cin >> x;
		w[i] = x;
	}
	
	HuffmanTree HT;
	HuffmanCode HC;
	HuffmanCoding(HT, HC, w, n);
	for(int i = 1;i <= n;i++) cout << HC[i] <<endl;
	
	return 0;
}
```

#### 第三题拓展

[参考网站](https://blog.csdn.net/qq_44769557/article/details/122261653)

> 题目
>
> 编写一个哈夫曼编码译码程序。
>
> 按词频从小到大的顺序给出各个字符（不超过30个）的词频，根据词频构造哈夫曼树，给出每个字符的哈夫曼编码，并对给出的语句进行译码。
>
> 为确保构建的哈夫曼树唯一，本题做如下限定：
>
> （1）选择根结点权值最小的两棵二叉树时，选取权值较小者作为左子树。
>
> （2）若多棵二叉树根结点权值相等，按先后次序分左右，先出现的作为左子树，后出现的作为右子树。
>
> 生成哈夫曼编码时，哈夫曼树左分支标记为0，右分支标记为1。
>
> 【输入格式】
>
> 第一行输入字符个数n；
>
> 第二行到第n行输入相应的字符及其权值；
>
> 最后一行输入需进行译码的串
>
> 【输出格式】
>
> 首先按树的先序顺序输出所有字符的编码，每个编码占一行；
>
> 最后一行输出需译码的原文，加上original:字样。
>
> 输出中均无空格
>
> 【样例输入】
>
> 3
>
> m1
>
> n1
>
> c2
>
> 10110
>
> 【样例输出】
>
> c:0
>
> m:10
>
> n:11
>
> original:mnc
>
> 题意：就是构建一颗哈夫曼树，根据该树确定每个字符的编码，根据编码解码
>
> 注意：
>
> 权值不等，左小右大
>
> 权值相等，先出现的为左。
>
> 左为0，右为1

```c++
#include <iostream>
#include<string>
#include<vector>
#include<map>
#include<algorithm>
#include<sstream>
using namespace std;

/**
 *  树结点
 */
struct TreeNode{
    double data; //权值
    char ch;//字符
    struct TreeNode *left=NULL;//左孩子,默认指向空
    struct TreeNode *right=NULL;//右孩子
};
map<string,char> m;  //定义一个map
bool cmp(TreeNode a,TreeNode b);
TreeNode* createTree(TreeNode *v,int n);
void printCode(struct TreeNode *root,char code[],int location);
void f_decode(string decoding,int len);
//升序 

int main()
{
    
    int n;
    cin>>n;
    getchar();//吸收回车字符
    //定义n个结点，使用vector存放
    TreeNode nodes[2*n-1];
    //输入n个结点
    for(int i=0;i<n;i++){
    	string line;
    	getline(cin,line);
    	stringstream inputline(line);
        inputline>>nodes[i].ch>>nodes[i].data;  
     
    }   
    //输入需进行译码的串
    string decoding; 
    getline(cin,decoding);
    int len = decoding.length();//统计长度
  
    //创建哈希树
	TreeNode* root=createTree(nodes,n);     
	char code[60]={0};//存储字符的编码
    //先序顺序输出所有字符的编码
    printCode(root,code,0);

    //解码
    /*
    for(int i=0;i<4;i++){//打印输入的一串字符
        printf("%c",decoding[i]);
    }
	printf("\n");
    
    cout<<"输出map："<<endl; 
    for(auto  &it:m){//打印map中的数据 
        string str=it.first;
        cout<<str<<":"<<it.second<<endl;
    }
    printf("\n字符串的长度为：%d\n",len);
    */
    f_decode(decoding,len);                             
    return 0;
}
/**
 * 创建树
 */
TreeNode* createTree(TreeNode *v,int n){  
    
    int i=0,index=n; //i为0 ，从位置0开始合成。index是生成的结点该放的地方
    while(i<2*n-1) //当i走到最后一个结点，无需再构建，也可以使用index控制
    {
        //1.先排序
        sort(v+i,v+index,cmp);  //只对范围内的排序。随两个索引变化，排序的范围也变化
        //2.合并:拿出排好序序列中的前两个结点。
        TreeNode* node1 = &v[i++];//TreeNode* node1 = &v[i];i++;
        TreeNode* node2 = &v[i++];

        //3.生成新节点，给结点赋值
        TreeNode newNode;
        newNode.data=node1->data+node2->data; //权值相加
        newNode.ch='-';//随意设置，表示其为中间结点。
        newNode.left=node1;//设置左右孩子
        newNode.right=node2;

        //4.新节点放入到序列中
        v[index++]=newNode;
    }
    return &v[2*n-2]; //最后一个为根节点
}

/**
 * 排序规则 
 */
bool cmp(TreeNode a, TreeNode b)
{
    return a.data < b.data; //根据权值升序排序
}

/**
 *解码 ，码——>原文
 */
void f_decode(string decoding,int len)
{
    string str;
    int i=0;
    printf("original:");
    for(i=0;i<len;i++)
    {
        str+=decoding[i];//拼接key
        if(m.find(str)!=m.end()){//找到了key，输出
            printf("%c",m[str]); 
            str="";//清空key，重新拼接
        }
        else
        {
            //找不到key，什么也不用做，继续拼接，这个可以去掉
        }
    }
   
}

/**
 * 先序顺序输出所有字符的编码
 */
void printCode(TreeNode *root,char code[],int location){
    if (root == NULL) {
        return;
    }
    if(root->ch!='-')//说明已经遍历到叶子节点，输出序列
    {   
        printf("%c:",root->ch);
        string key="";
        for(int i=0;i<location;i++){//输出记录的长度。
            printf("%d",code[i]);   
            key+=to_string(code[i]);//to_string()将参数转为string类型
        }
        printf("\n");
       	//cout<<"key:"<<key<<","<<"value："<<root->ch<<endl;
        m.insert(make_pair(key, root->ch));//将值以键值对的形式插入到map中
    }
    //该节点是左孩子,路径设0        
        code[location]=0; 
        location++;//下一个位置给下一个节点用
        printCode(root->left,code,location); //递归该节点。
        location--;//该节点递归完成。取消该节点的记录。
    
    //右孩子,1
        code[location]=1;
        location++;
        printCode(root->right,code,location);
        location--;
}
```

![img](https://img-blog.csdnimg.cn/e383f20ca99548c5bc23befd17c443e2.png)

### ==树==

![image-20230506164758218](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230506164758218.png)

> ==找二叉树遍历的简便方法==

![二叉搜索树的前、中、后序遍历](https://www.hello-algo.com/chapter_tree/binary_tree_traversal.assets/binary_tree_dfs.png)

## 第七次实验（图）

### 拓展知识

![image-20230509235449826](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230509235449826.png)

![image-20230509235906151](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230509235906151.png)

> STL容器
>
> 向量（vector）

![image-20230510000048496](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230510000048496.png)

![image-20230510073908853](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230510073908853.png)

![image-20230510075458866](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230510075458866.png)

+ DFS模板题

![image-20230510083102179](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230510083102179.png)

![image-20230510082650821](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230510082650821.png)

> 在 C 语言中，`enum` 是一种枚举类型，它允许我们定义一个包含一组常量的新类型。
>
> `enum` 的语法如下：
>
> 
>
> ```c
> Copy codeenum enum_name {
>    value1,
>    value2,
>    value3,
>    ...
> };
> ```
>
> 其中，`enum_name` 是枚举类型的名称，`value1`、`value2`、`value3` 等是枚举类型的常量。每个常量都有一个整数值，第一个常量默认值为 0，后续常量的值会依次自增 1。
>
> 
>
> 以下是一个使用 `enum` 的示例：
>
> 
>
> ```c
> Copy code#include <stdio.h>
> 
> enum week {
>     Monday,
>     Tuesday,
>     Wednesday,
>     Thursday,
>     Friday,
>     Saturday,
>     Sunday
> };
> 
> int main() {
>     enum week today;
>     today = Wednesday;
>     printf("Today is %dth day of the week\n", today+1);
>     return 0;
> }
> ```
>
> 
>
> 在这个示例中，我们定义了一个枚举类型 `week`，其中包含了一组常量，表示一周中的每一天。在 `main()` 函数中，我们声明了一个 `today` 变量，它的类型是 `week`，并将其赋值为 `Wednesday`。最后，我们使用 `printf()` 函数输出 `today` 的值，即星期三的编号，输出结果为 `Today is 3th day of the week`。

### 头文件

```c++
#ifndef MYGRAPH_H
#define MYGRAPH_H
#include<iostream>
#include<climits>
#define MAXN 20
#define MaxInt INT_MAX
using namespace std;

typedef char VertexType;
typedef int ArcType;

typedef struct{
	VertexType vexs[MAXN];
	ArcType arcs[MAXN][MAXN];
	int vexnum, arcnum;
}MGraph;

// 找到n在G中的对应位置 
int LocateVex(MGraph G, VertexType n)
{
	int num = 0;
	while(G.vexs[num] != n) num++;
	return num;
}

void CreatUDG(MGraph &G)
{
	cin >> G.vexnum >> G.arcnum;
	// 输入顶点信息 
	for(int i = 0;i < G.vexnum;i++)
	{
		cin >> G.vexs[i];
	}
	
	// 初始化邻接矩阵，边的权值均置为极大值MaxInt 
	for(int i = 0;i < G.vexnum;i++)
		for(int j = 0;j < G.vexnum;j++)
			G.arcs[i][j] = MaxInt;
			
	// 构造邻接矩阵 
	for(int i = 0;i < G.arcnum;i++)
	{
		VertexType v1, v2;
		ArcType w;
		cin >> v1 >> v2 >> w;
		int x = LocateVex(G, v1);
		int y = LocateVex(G, v2);
//		cout << x << " " << y << " " << w << endl;
		G.arcs[x][y] = w;
		G.arcs[y][x] = G.arcs[x][y];	// 无向图是对称矩阵 
	}
		
}


// ∞
void PrintUDG(MGraph G)
{
	for(int i = 0;i < G.arcnum;i++)
	{
		for(int j = 0;j < G.arcnum;j++)
		{
			if(G.arcs[i][j] != MaxInt) cout << G.arcs[i][j] << "   ";
			else cout << "∞" << " ";
		}
		cout << endl;	
	}		
}


int FirstAdjVex(MGraph G, int v)
{
	for(int i = 0;i < G.vexnum;i++)
	{
		if(G.arcs[v][i] != MaxInt) return i;
	}
	return -1;
}

int NextAdjVex(MGraph G, int v, int w)
{
	if(G.arcs[v][w] != MaxInt)
	{
		for(int i = w + 1;i < G.vexnum;i++)
		{
			if(G.arcs[v][i] != MaxInt) return i;
		}
		return -1;
	}
	return -1;
}
#endif
```

```c++
#ifndef MYQUEUE1_H
#define MYQUEUE1_H
#include<iostream>
#include<cstdlib>
using namespace std;

typedef struct QNode{
    int data;
    struct QNode *next;
}QNode,*QueuePtr;

typedef struct{
    QueuePtr front;
    QueuePtr rear;
}LinkQueue;

void InitQueue(LinkQueue &Q)
{
    Q.front = Q.rear = (QueuePtr)malloc(sizeof(QNode));
    Q.front->next = NULL;
}

void DestroyQueue(LinkQueue &Q)
{
    while(Q.front)
    {
        Q.rear = Q.front->next;
        free(Q.front);
        Q.front = Q.rear;
    }
}
 
 void EnQueue(LinkQueue &Q, int e)
 {
     QueuePtr p;
     p = (QueuePtr)malloc(sizeof(QNode));
     p->data = e;
     p->next = NULL;
     Q.rear->next = p;
     Q.rear = p;
 }
 
 void DeQueue(LinkQueue &Q, int &e)
 {
     QueuePtr p;
     if(Q.front == Q.rear) return;
     p = Q.front->next;
     e = p->data;
     Q.front->next = p->next;
     if(Q.rear == p) Q.rear = Q.front;
     free(p);
 }
 
 void PrintQueue(LinkQueue Q)
 {
     QueuePtr p;
     p = Q.front->next;
     while(p != NULL)
     {
         cout << p->data << " ";
         p = p->next;
     }
 }
 
 bool isEmptyQueue(LinkQueue Q)
 {
    if(Q.front == Q.rear) return true;
    else return false;
 }

 void TopQueue(LinkQueue Q, int &e)
 {
    e = Q.front->next->data;
 }

int QueueLength(LinkQueue Q)
{
	int cnt = 0;
	QueuePtr p;
	p = Q.front->next;
	while(p != NULL)
	{
		cnt++;
		p = p->next;
	}
	return cnt;
}
#endif
```

### 第一题

![image-20230517151610461](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230517151610461.png)

```c++
#include"myGraph.h"

int main()
{
	MGraph G;
	CreatUDG(G);
	PrintUDG(G);
	return 0;
}
```

### 第二题

![image-20230517151849482](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230517151849482.png)

```c++
#include<iostream>
#include<cstdlib>
#define MAXN 20

using namespace std;

typedef char VertexType;
typedef int InfoType;

//边结点的类型定义 
typedef struct ArcNode{
	int adjvex;					// 边的另一顶点的在数组中的位置 
	struct ArcNode *nextarc;	// 指向下一条边的指针
	InfoType info;
}ArcNode; 

//顶点结点 
typedef struct VNode{
	VertexType data;	// 顶点信息
	ArcNode *firstarc;	//指向关联该顶点的边链表 
}VNode, AdjList[MAXN];

typedef struct{
	AdjList vertices;
	int vexnum, arcnum;	// 图的当前顶点数和边数 
}ALGragh;

// 找到n在G中的对应位置 
int LocateVex(ALGragh G, VertexType n)
{
	int num = 0;
	while(G.vertices[num].data != n) num++;
	return num;
}

void CreatUDG(ALGragh &G)
{
	cin >> G.vexnum >> G.arcnum;
	
	//输入各顶点，构造表头结点 
	for(int i = 0; i < G.vexnum;i++)
	{
		cin >> G.vertices[i].data;
		G.vertices[i].firstarc = NULL;
	}
	
	//输入各边，构造邻接表 
	for(int i = 0;i < G.arcnum;i++)
	{
		VertexType v1, v2;
		InfoType w;
		cin >> v1 >> v2 >> w;
		//确定v1、v2在G中的位置 
		int x = LocateVex(G,v1);
		int y = LocateVex(G,v2);
		
		ArcNode *p1, *p2;
		p1 = (ArcNode*)malloc(sizeof(ArcNode));
		p1->adjvex = y;
		p1->nextarc = G.vertices[x].firstarc;
		p1->info = w;
		G.vertices[x].firstarc = p1;	//将新结点插入到顶点vi的边链表头部 
		
		p2 = (ArcNode*)malloc(sizeof(ArcNode));
		p2->adjvex = x;
		p2->nextarc = G.vertices[y].firstarc;
		p2->info = w;
		G.vertices[y].firstarc = p2;	//将新结点插入到顶点vj的边链表头部 	 	
	}
}

void PrintUDG(ALGragh G)
{
	for(int i = 0;i < G.vexnum;i++)
	{
		cout << G.vertices[i].data << '\t';	// 输出表头结点信息 
		// 输出表头结点连着的信息 
		while(G.vertices[i].firstarc != NULL) 
		{
			cout << G.vertices[i].firstarc->adjvex << " ";	// 输出边结点的序号 
			cout << G.vertices[i].firstarc->info << '\t';	// 输出边的权值 
			G.vertices[i].firstarc = G.vertices[i].firstarc->nextarc;	// 指针后移 
		}
		cout << endl;
	}
}
int main()
{
	ALGragh G;
	CreatUDG(G);
	PrintUDG(G);
	return 0;
}
```

### 第三题

![image-20230517151902967](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230517151902967.png)

```c++
#include"myGraph.h"

using namespace std;
bool vis[MAXN];
void DFS(MGraph G, int v)
{
	cout << G.vexs[v] << " ";
	vis[v] = true;
	//依次检查V的所有邻接点w，FirstAdjVex(G, v)表示v的第一个邻接点  
	// NextAdjVex(G, v, w)表示v的相对于w的下一个邻接点，w≥0表示存在邻接点 
	for(int w = FirstAdjVex(G, v); w >= 0; w = NextAdjVex(G, v, w))
		if(!vis[w]) DFS(G, w);
}
int main()
{
	MGraph G; 
	CreatUDG(G);
	
	// 保证在非联通图的状态下也能实现全部访问 
	for(int v = 0; v < G.vexnum; v++) 
		if(!vis[v]) DFS(G, v);
	
	return 0;
}
```

### 第四题

![image-20230517152008373](https://yeyi0003.oss-cn-hangzhou.aliyuncs.com/image-20230517152008373.png)

```c++
#include"myGraph.h"
#include"myQueue1.h"

using namespace std;
bool vis[MAXN];

void BFS(MGraph G, int v)
{
	// 按广度优先非递归遍历图G，使用辅助队列Q 
	LinkQueue Q;
	InitQueue(Q);
	
	for(int v = 0; v < G.vexnum; v++)
	{
		if(!vis[v])
		{
			vis[v] = true;
			cout << G.vexs[v] << " ";
			EnQueue(Q, v);
			
			while(!isEmptyQueue(Q))
			{
				int u;
				DeQueue(Q, u);
				for(int w = FirstAdjVex(G, u); w >= 0; w = NextAdjVex(G, u, w))
					if(!vis[w])
					{
						vis[w] = true;
						cout << G.vexs[w] << " ";
						EnQueue(Q, w);
					}
			}				
		}
	
	}

	
}

int main()
{
	MGraph G; 
	CreatUDG(G);
	
	BFS(G, 0);
	return 0;
}
```

